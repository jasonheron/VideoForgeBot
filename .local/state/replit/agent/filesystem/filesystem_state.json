{"file_contents":{"BOTFATHER_SETUP_GUIDE.md":{"content":"# ü§ñ BotFather Setup Guide - AI Video Generator Bot\n\nThis comprehensive guide will help you configure your Telegram bot through BotFather to create a professional, user-friendly experience that matches the enhanced UI of the AI Video Generator Bot.\n\n## üìã Table of Contents\n\n1. [Basic Bot Setup](#basic-bot-setup)\n2. [Bot Profile Configuration](#bot-profile-configuration)\n3. [Command Setup](#command-setup)\n4. [Menu Button Configuration](#menu-button-configuration)\n5. [Bot Settings](#bot-settings)\n6. [Advanced Features](#advanced-features)\n7. [Testing Your Setup](#testing-your-setup)\n\n---\n\n## üöÄ Basic Bot Setup\n\n### Step 1: Create Your Bot\n1. **Start BotFather**: Message [@BotFather](https://t.me/BotFather) on Telegram\n2. **Create new bot**: Send `/newbot`\n3. **Choose bot name**: Enter a display name like \"AI Video Generator\"\n4. **Choose username**: Enter a unique username ending in \"bot\" (e.g., `ai_video_generator_bot`)\n5. **Save your token**: Copy and securely store the bot token provided\n\n---\n\n## üé® Bot Profile Configuration\n\n### Step 2: Set Bot Description\n```\n/setdescription\n```\n**Recommended Description:**\n```\nüé¨ AI Video Generator Bot\n\nCreate stunning AI videos with advanced models like Veo 3, Runway Gen-3, and Kling 2.1. Upload images, write prompts, and get professional videos in minutes.\n\n‚ú® Features:\n‚Ä¢ 9 premium AI models\n‚Ä¢ Image-to-video conversion\n‚Ä¢ High-quality output\n‚Ä¢ Secure Telegram Stars payment\n‚Ä¢ Instant delivery\n\nüí∞ 1 credit = 100 Stars ‚âà $1.30\nüöÄ Start creating amazing videos now!\n```\n\n### Step 3: Set About Text\n```\n/setabouttext\n```\n**Recommended About:**\n```\nüé¨ Professional AI Video Generation\n\nCreate high-quality videos using cutting-edge AI models. Support for text-to-video and image-to-video with instant delivery.\n\nü§ñ 9 AI Models Available\nüí≥ Secure Payment via Telegram Stars\n‚ö° 2-5 Minute Generation Time\nüéØ Professional Quality Output\n```\n\n### Step 4: Set Profile Photo\n```\n/setuserpic\n```\n**Upload a professional profile picture**:\n- Size: 512x512 pixels recommended\n- Format: PNG or JPG\n- Design: Clean, professional logo or icon representing video/AI\n- Colors: Modern, trustworthy colors (blue, purple, or professional gradients)\n\n---\n\n## üîß Command Setup\n\n### Step 5: Configure Bot Commands\n```\n/setcommands\n```\n**Copy and paste this exact command list:**\n```\nstart - üè† Main menu and welcome\ngenerate - üé¨ Create AI video\nbuy - üí≥ Purchase credits\nhelp - ‚ùì Help and support\n```\n\n### Command Details:\n- **start** - Shows enhanced welcome message with quick action buttons\n- **generate** - Initiates video generation with model selection\n- **buy** - Opens credit purchase with Telegram Stars\n- **help** - Comprehensive help system with guides\n\n---\n\n## üì± Menu Button Configuration\n\n### Step 6: Set Menu Button\n```\n/setmenubutton\n```\n**Button Text:** `üé¨ Generate Video`\n**Button Type:** Choose \"commands\"\n**Command:** `/generate`\n\nThis creates a prominent menu button that appears next to the message input, making video generation easily accessible.\n\n---\n\n## ‚öôÔ∏è Bot Settings\n\n### Step 7: Privacy Settings\n```\n/setprivacy\n```\n**Choose:** `Disable` \nThis allows your bot to work in groups if needed and receive all messages.\n\n### Step 8: Join Groups Setting\n```\n/setjoingroups\n```\n**Choose:** `Disable` (unless you want group functionality)\nFor a payment bot, it's usually better to keep it private.\n\n### Step 9: Inline Mode (Optional)\n```\n/setinline\n```\n**Placeholder text:** `Search AI video models...`\nThis allows users to use your bot inline in other chats (optional feature).\n\n### Step 10: Set Domain (Optional)\n```\n/setdomain\n```\nIf you have a website, you can set your domain for additional verification.\n\n---\n\n## üéØ Advanced Features\n\n### Step 11: Bot Info Page Setup\n```\n/mybots\n```\nSelect your bot, then:\n\n1. **Edit Bot Info** ‚Üí Add detailed information about features\n2. **Bot Settings** ‚Üí Review all settings\n3. **Payments** ‚Üí Ensure Telegram Stars is enabled (should be default)\n\n### Step 12: Rich Command Descriptions\nFor each command, you can add rich descriptions in your bot's code. The enhanced UI already includes:\n\n- **Emoji icons** for visual appeal\n- **Clear descriptions** of what each command does\n- **Professional formatting** with markdown\n- **Helpful hints** and usage tips\n\n---\n\n## üß™ Testing Your Setup\n\n### Step 13: Test All Configurations\n\n1. **Profile Test:**\n   - Check bot profile photo appears correctly\n   - Verify description shows in bot info\n   - Confirm about text is visible\n\n2. **Command Test:**\n   - Type `/` in chat with your bot\n   - Verify all commands appear with descriptions\n   - Test each command works properly\n\n3. **Menu Button Test:**\n   - Check the menu button appears next to message input\n   - Verify it triggers the correct command\n   - Ensure it works on both mobile and desktop\n\n4. **Payment Test:**\n   - Verify Telegram Stars payment works\n   - Test the credit purchase flow\n   - Confirm credits are added correctly\n\n---\n\n## üìù Additional BotFather Commands Reference\n\n### Useful Commands for Maintenance:\n```\n/mybots - Manage all your bots\n/deletebot - Delete a bot (careful!)\n/token - Get your bot token again\n/revoke - Revoke and generate new token\n/setcommands - Update command list\n/deletecommands - Remove all commands\n```\n\n### Bot Analytics:\n```\n/stats - View bot usage statistics (if available)\n```\n\n---\n\n## üé® UI Enhancement Recommendations\n\n### Visual Consistency:\n- Use consistent emoji schemes throughout\n- Maintain professional color schemes\n- Ensure all buttons use clear, action-oriented text\n- Keep messaging tone friendly but professional\n\n### User Experience:\n- Test the complete user journey from start to video delivery\n- Ensure error messages are helpful and actionable\n- Verify all callback buttons work correctly\n- Test payment flow thoroughly\n\n### Mobile Optimization:\n- Test on both iOS and Android Telegram apps\n- Verify buttons are easily tappable\n- Ensure text is readable on small screens\n- Check that inline keyboards display correctly\n\n---\n\n## ‚úÖ Setup Checklist\n\nUse this checklist to ensure everything is configured:\n\n- [ ] Bot created with professional name and username\n- [ ] Description set with all features highlighted\n- [ ] About text configured with key benefits\n- [ ] Professional profile photo uploaded\n- [ ] All commands configured with descriptions\n- [ ] Menu button set to \"Generate Video\"\n- [ ] Privacy settings configured appropriately\n- [ ] Group join settings set to disable\n- [ ] Bot token securely stored in environment variables\n- [ ] Payment system tested with Telegram Stars\n- [ ] All callback buttons working correctly\n- [ ] Help system fully functional\n- [ ] Error handling tested\n- [ ] Mobile experience verified\n- [ ] Desktop experience verified\n\n---\n\n## üöÄ Launch Preparation\n\n### Before Going Live:\n1. **Test extensively** with multiple users\n2. **Verify payment flows** work correctly\n3. **Check all help content** is accurate\n4. **Ensure error messages** are helpful\n5. **Test with different device types**\n6. **Verify generation workflow** end-to-end\n\n### Marketing Copy for Bot Store:\nWhen submitting to bot directories, use this description:\n\n```\nüé¨ AI Video Generator Bot - Create Professional Videos with AI\n\nTransform your ideas into stunning videos using cutting-edge AI models including Google Veo 3, Runway Gen-3, and Kling 2.1. Perfect for content creators, marketers, and anyone wanting to create engaging video content.\n\nüåü Key Features:\n‚Ä¢ 9 Premium AI Models\n‚Ä¢ Text-to-Video Generation\n‚Ä¢ Image-to-Video Animation\n‚Ä¢ Professional Quality Output\n‚Ä¢ Secure Telegram Stars Payment\n‚Ä¢ 2-5 Minute Generation Time\n‚Ä¢ Direct Video Delivery\n\nüí∞ Affordable Pricing: 1 Credit = 100 Stars (‚âà$1.30)\nüöÄ No Registration Required - Start Creating Immediately\nüîí Secure Payment via Telegram Stars\n```\n\n---\n\n## üìû Support and Troubleshooting\n\n### Common BotFather Issues:\n- **Commands not updating**: Use `/setcommands` again and wait a few minutes\n- **Profile photo not showing**: Ensure image is under 5MB and proper format\n- **Menu button missing**: Disable and re-enable, or contact Telegram support\n- **Description too long**: Keep under character limits (120 for about, 512 for description)\n\n### Bot-Specific Issues:\n- **Payments not working**: Check bot token and webhook configuration\n- **Callbacks failing**: Verify all callback handlers are implemented\n- **Images not uploading**: Test file size and format restrictions\n- **Messages not formatting**: Check markdown syntax\n\n---\n\n**üéâ Congratulations!** Your AI Video Generator Bot is now professionally configured and ready to provide an amazing user experience!\n\nFor ongoing maintenance, regularly check BotFather for new features and keep your bot's information updated as you add new capabilities.","size_bytes":8832},"main.py":{"content":"import os\nimport logging\nimport json\nimport asyncio\nimport hmac\nimport hashlib\nimport tempfile\nimport time\nfrom typing import Dict, Optional\nfrom aiohttp import web, ClientSession\nfrom dotenv import load_dotenv\n\n# Load environment variables from .env file\nload_dotenv()\nfrom aiogram import Bot, Dispatcher, types, F\nfrom aiogram.types import (\n    Message, CallbackQuery, InlineKeyboardMarkup, InlineKeyboardButton,\n    LabeledPrice, PreCheckoutQuery, ContentType, BufferedInputFile, Update,\n    InaccessibleMessage\n)\nfrom aiogram.filters import Command\nfrom aiogram.fsm.context import FSMContext\nfrom aiogram.fsm.state import State, StatesGroup\nfrom aiogram.fsm.storage.memory import MemoryStorage\nimport aiofiles\n\n# Configure logging\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(__name__)\n\n# Configuration\nBOT_TOKEN = os.getenv(\"BOT_TOKEN\", \"your_telegram_bot_token_here\")\n# Support both BRS_AI_API_KEY (new) and KIE_AI_API_KEY (legacy) for backward compatibility\nBRS_AI_API_KEY = os.getenv(\"BRS_AI_API_KEY\") or os.getenv(\"KIE_AI_API_KEY\")\nif not BRS_AI_API_KEY:\n    BRS_AI_API_KEY = \"your_brs_ai_api_key_here\"\nelif os.getenv(\"KIE_AI_API_KEY\") and not os.getenv(\"BRS_AI_API_KEY\"):\n    logger.warning(\"Using legacy KIE_AI_API_KEY environment variable. Consider updating to BRS_AI_API_KEY for future compatibility.\")\nPAYMENT_PROVIDER_TOKEN = os.getenv(\"PAYMENT_PROVIDER_TOKEN\", \"your_payment_provider_token\")\nWEBHOOK_URL = os.getenv(\"WEBHOOK_URL\", \"https://your-repl-url.replit.dev\")\nCALLBACK_SECRET = os.getenv(\"CALLBACK_SECRET\", \"your_callback_secret_key_here\")  # New security key\n\n# Admin Configuration - Restricted Access\nADMIN_USER_ID = 2146010529  # @niftysolsol only\n\n# Initialize Bot and Dispatcher\nbot = Bot(token=BOT_TOKEN)\ndp = Dispatcher(storage=MemoryStorage())\n\n# Global HTTP client session\nhttp_session: Optional[ClientSession] = None\n\n# Persistent storage files\nCREDITS_FILE = \"user_credits.json\"\nGENERATIONS_FILE = \"pending_generations.json\"\nMODELS_FILE = \"user_models.json\"\nCLEANUP_FILE = \"message_cleanup.json\"\n\n# In-memory caches (loaded from persistent storage)\nuser_models: Dict[int, str] = {}  # Store selected model per user\npending_generations: Dict[str, dict] = {}  # Track pending generations\nmessage_cleanup: Dict[str, dict] = {}  # Track messages to cleanup after generation\n\ndef get_credit_account_id(message: Message) -> int:\n    \"\"\"\n    Get the appropriate credit account ID based on chat type.\n    For private chats: use user_id\n    For groups: use chat_id (negative number)\n    \"\"\"\n    if message.chat.type in ['group', 'supergroup']:\n        return message.chat.id  # Negative number for groups\n    else:\n        return message.from_user.id if message.from_user else 0  # User ID for private chats\n\ndef is_group_chat(message: Message) -> bool:\n    \"\"\"Check if message is from a group chat\"\"\"\n    return message.chat.type in ['group', 'supergroup']\n\ndef get_callback_account_id(callback: CallbackQuery) -> int:\n    \"\"\"Get account ID for callback based on message source\"\"\"\n    if callback.message and callback.message.chat.type in ['group', 'supergroup']:\n        return callback.message.chat.id  # Group ID (negative)\n    elif callback.from_user:\n        return callback.from_user.id  # User ID (positive)\n    else:\n        return 0\n\ndef load_user_credits() -> Dict[int, int]:\n    \"\"\"\n    Load credits from persistent storage.\n    Supports both user credits (positive IDs) and group credits (negative IDs)\n    \"\"\"\n    try:\n        if os.path.exists(CREDITS_FILE):\n            with open(CREDITS_FILE, 'r') as f:\n                # JSON keys are strings, convert back to int\n                data = json.load(f)\n                return {int(k): v for k, v in data.items()}\n        return {}\n    except Exception as e:\n        logger.error(f\"Error loading credits: {e}\")\n        return {}\n\ndef save_user_credits():\n    \"\"\"\n    Save credits to persistent storage.\n    Supports both user credits (positive IDs) and group credits (negative IDs)\n    \"\"\"\n    try:\n        with open(CREDITS_FILE, 'w') as f:\n            json.dump(user_credits, f, indent=2)\n        logger.info(\"Credits saved to persistent storage\")\n    except Exception as e:\n        logger.error(f\"Error saving credits: {e}\")\n\ndef load_pending_generations() -> Dict[str, dict]:\n    \"\"\"Load pending generations from persistent storage\"\"\"\n    try:\n        if os.path.exists(GENERATIONS_FILE):\n            with open(GENERATIONS_FILE, 'r') as f:\n                return json.load(f)\n    except Exception as e:\n        logger.error(f\"Error loading pending generations: {e}\")\n    return {}\n\ndef save_pending_generations():\n    \"\"\"Save pending generations to persistent storage\"\"\"\n    try:\n        with open(GENERATIONS_FILE, 'w') as f:\n            json.dump(pending_generations, f, indent=2)\n        logger.info(\"Pending generations saved to persistent storage\")\n    except Exception as e:\n        logger.error(f\"Error saving pending generations: {e}\")\n\ndef load_user_models() -> Dict[int, str]:\n    \"\"\"Load user models from persistent storage\"\"\"\n    try:\n        if os.path.exists(MODELS_FILE):\n            with open(MODELS_FILE, 'r') as f:\n                # Convert string keys back to integers\n                data = json.load(f)\n                return {int(k): v for k, v in data.items()}\n    except Exception as e:\n        logger.error(f\"Error loading user models: {e}\")\n    return {}\n\ndef save_user_models():\n    \"\"\"Save user models to persistent storage\"\"\"\n    try:\n        with open(MODELS_FILE, 'w') as f:\n            json.dump(user_models, f, indent=2)\n        logger.info(\"User models saved to persistent storage\")\n    except Exception as e:\n        logger.error(f\"Error saving user models: {e}\")\n\ndef load_message_cleanup() -> Dict[str, dict]:\n    \"\"\"Load message cleanup data from persistent storage\"\"\"\n    try:\n        if os.path.exists(CLEANUP_FILE):\n            with open(CLEANUP_FILE, 'r') as f:\n                return json.load(f)\n    except Exception as e:\n        logger.error(f\"Error loading message cleanup: {e}\")\n    return {}\n\ndef save_message_cleanup():\n    \"\"\"Save message cleanup data to persistent storage\"\"\"\n    try:\n        with open(CLEANUP_FILE, 'w') as f:\n            json.dump(message_cleanup, f, indent=2)\n        logger.info(\"Message cleanup data saved to persistent storage\")\n    except Exception as e:\n        logger.error(f\"Error saving message cleanup: {e}\")\n\ndef track_message_for_cleanup(generation_id: str, message_id: int, chat_id: int, message_type: str = \"bot\"):\n    \"\"\"Track a message that should be deleted after generation completes\"\"\"\n    if generation_id not in message_cleanup:\n        message_cleanup[generation_id] = {\n            \"chat_id\": chat_id,\n            \"messages\": []\n        }\n    \n    message_cleanup[generation_id][\"messages\"].append({\n        \"message_id\": message_id,\n        \"type\": message_type  # \"bot\", \"user\", \"command\"\n    })\n    save_message_cleanup()\n    logger.info(f\"Tracking message {message_id} for cleanup in generation {generation_id}\")\n\ndef is_admin(user_id: int) -> bool:\n    \"\"\"Check if user is admin\"\"\"\n    return user_id == ADMIN_USER_ID\n\nasync def cleanup_generation_messages(generation_id: str, keep_final_message_id: Optional[int] = None):\n    \"\"\"Delete all tracked messages for a generation except optionally one final message\"\"\"\n    if generation_id not in message_cleanup:\n        return\n    \n    cleanup_data = message_cleanup[generation_id]\n    chat_id = cleanup_data[\"chat_id\"]\n    messages_to_delete = cleanup_data[\"messages\"]\n    \n    if not messages_to_delete:\n        return\n    \n    # Delete messages in groups only to reduce clutter\n    if int(chat_id) < 0:  # Negative chat_id indicates group\n        deleted_count = 0\n        for msg_data in messages_to_delete:\n            message_id = msg_data[\"message_id\"]\n            \n            # Skip the final message if specified\n            if keep_final_message_id and message_id == keep_final_message_id:\n                continue\n                \n            try:\n                await bot.delete_message(chat_id=chat_id, message_id=message_id)\n                deleted_count += 1\n                logger.info(f\"Deleted message {message_id} in group {chat_id}\")\n            except Exception as e:\n                logger.warning(f\"Could not delete message {message_id} in chat {chat_id}: {e}\")\n        \n        logger.info(f\"Cleaned up {deleted_count} messages for generation {generation_id} in group {chat_id}\")\n    \n    # Remove cleanup data\n    del message_cleanup[generation_id]\n    save_message_cleanup()\n\n# Load existing data on startup\nuser_credits: Dict[int, int] = load_user_credits()\npending_generations = load_pending_generations()\nuser_models = load_user_models()\nmessage_cleanup = load_message_cleanup()\nlogger.info(f\"Loaded {len(user_credits)} user credit accounts from storage\")\nlogger.info(f\"Loaded {len(pending_generations)} pending generations from storage\")\nlogger.info(f\"Loaded {len(user_models)} user model selections from storage\")\nlogger.info(f\"Loaded {len(message_cleanup)} message cleanup records from storage\")\n\n# Simplified available models - streamlined selection\nAVAILABLE_MODELS = {\n    \"veo3_fast\": \"‚ö° Veo 3 Fast - Quick generation with images\", \n    \"runway_gen3\": \"üöÄ Runway Gen-3 - Advanced video generation\",\n    \"wan_2_2_t2v\": \"üìù Wan 2.2 - Text to video\",\n    \"wan_2_2_i2v\": \"üñºÔ∏è Wan 2.2 - Image to video\",\n    \"kling_standard\": \"üí∞ Kling 2.1 - Image to video (720p)\",\n    \"sora_2_t2v\": \"‚ú® Sora 2 - Text to video\",\n    \"sora_2_i2v\": \"üé¨ Sora 2 - Image to video\"\n}\n\n# Models that skip image upload (text-to-video only)\nTEXT_ONLY_MODELS = {\"wan_2_2_t2v\", \"sora_2_t2v\"}\n\n# FSM States\nclass GenerationStates(StatesGroup):\n    waiting_for_prompt = State()\n    waiting_for_image = State()\n\n# Helper functions\ndef get_credits(account_id: int) -> int:\n    \"\"\"\n    Get credits for account (user or group).\n    Positive IDs = user accounts, Negative IDs = group accounts\n    \"\"\"\n    if account_id == 0:\n        logger.error(\"Invalid account_id: 0 - cannot retrieve credits\")\n        return 0\n    return user_credits.get(account_id, 0)\n\ndef get_user_credits(user_id: int) -> int:\n    \"\"\"Legacy function for backward compatibility\"\"\"\n    return get_credits(user_id)\n\ndef add_credits(account_id: int, amount: int):\n    \"\"\"\n    Add credits to account (user or group).\n    Positive IDs = user accounts, Negative IDs = group accounts\n    \"\"\"\n    if account_id == 0:\n        logger.error(\"Invalid account_id: 0 - cannot add credits\")\n        return\n    if account_id not in user_credits:\n        user_credits[account_id] = 0\n    user_credits[account_id] += amount\n    save_user_credits()  # Save to persistent storage\n    account_type = \"group\" if account_id < 0 else \"user\"\n    logger.info(f\"Added {amount} credits to {account_type} {account_id}. Total: {user_credits[account_id]}\")\n\ndef deduct_credits(account_id: int, amount: int) -> bool:\n    \"\"\"\n    Deduct credits from account (user or group). Returns True if successful.\n    Positive IDs = user accounts, Negative IDs = group accounts\n    \"\"\"\n    if account_id == 0:\n        logger.error(\"Invalid account_id: 0 - cannot deduct credits\")\n        return False\n    current_credits = get_credits(account_id)\n    if current_credits >= amount:\n        user_credits[account_id] = current_credits - amount\n        save_user_credits()  # Save to persistent storage\n        account_type = \"group\" if account_id < 0 else \"user\"\n        logger.info(f\"Deducted {amount} credits from {account_type} {account_id}. Remaining: {user_credits[account_id]}\")\n        return True\n    return False\n\ndef create_model_selection_keyboard():\n    \"\"\"Create simplified full-width keyboard for model selection\"\"\"\n    keyboard = []\n    \n    # Add each model as a full-width button for better readability\n    for model_key, model_name in AVAILABLE_MODELS.items():\n        keyboard.append([InlineKeyboardButton(\n            text=model_name,\n            callback_data=f\"model_{model_key}\"\n        )])\n    \n    # Add action buttons in pairs\n    keyboard.append([\n        InlineKeyboardButton(text=\"üîÑ Reset Selection\", callback_data=\"reset_model\"),\n        InlineKeyboardButton(text=\"üí∞ Buy Credits\", callback_data=\"buy_credits\")\n    ])\n    keyboard.append([\n        InlineKeyboardButton(text=\"‚ùì Help\", callback_data=\"help_models\"),\n        InlineKeyboardButton(text=\"üîô Back to Menu\", callback_data=\"back_main\")\n    ])\n    \n    return InlineKeyboardMarkup(inline_keyboard=keyboard)\n\ndef verify_callback_signature(payload: bytes, signature: str) -> bool:\n    \"\"\"Verify HMAC signature for callback authentication\"\"\"\n    try:\n        expected_signature = hmac.new(\n            CALLBACK_SECRET.encode('utf-8'),\n            payload,\n            hashlib.sha256\n        ).hexdigest()\n        return hmac.compare_digest(signature, expected_signature)\n    except Exception as e:\n        logger.error(f\"Error verifying callback signature: {e}\")\n        return False\n\nasync def safe_edit_message(callback: CallbackQuery, text: str, reply_markup=None, parse_mode: Optional[str] = None) -> bool:\n    \"\"\"\n    Safely edit callback message with proper type checking.\n    Returns True if message was successfully edited, False if sent as new message.\n    \"\"\"\n    try:\n        if callback.message and isinstance(callback.message, types.Message):\n            await callback.message.edit_text(text, reply_markup=reply_markup, parse_mode=parse_mode)\n            return True\n        elif callback.from_user:\n            await bot.send_message(callback.from_user.id, text, reply_markup=reply_markup, parse_mode=parse_mode)\n            return False\n        else:\n            logger.warning(\"Unable to edit message or send new message - no user info\")\n            return False\n    except Exception as e:\n        logger.error(f\"Error in safe_edit_message: {e}\")\n        # Fallback: try to send as new message\n        if callback.from_user:\n            try:\n                await bot.send_message(callback.from_user.id, text, reply_markup=reply_markup, parse_mode=parse_mode)\n                return False\n            except Exception as fallback_error:\n                logger.error(f\"Fallback message send also failed: {fallback_error}\")\n        return False\n\nasync def download_telegram_file(file_id: str) -> Optional[bytes]:\n    \"\"\"Download file from Telegram and return its content\"\"\"\n    try:\n        file_info = await bot.get_file(file_id)\n        if not file_info.file_path:\n            logger.error(f\"No file path for file_id: {file_id}\")\n            return None\n            \n        # Download file using aiohttp\n        global http_session\n        if not http_session:\n            http_session = ClientSession()\n            \n        file_url = f\"https://api.telegram.org/file/bot{BOT_TOKEN}/{file_info.file_path}\"\n        \n        async with http_session.get(file_url) as response:\n            if response.status == 200:\n                content = await response.read()\n                logger.info(f\"Successfully downloaded file {file_id}, size: {len(content)} bytes\")\n                return content\n            else:\n                logger.error(f\"Failed to download file {file_id}: HTTP {response.status}\")\n                return None\n                \n    except Exception as e:\n        logger.error(f\"Error downloading Telegram file {file_id}: {e}\")\n        return None\n\nasync def upload_image_to_temporary_storage(image_content: bytes, filename: str) -> Optional[str]:\n    \"\"\"Upload image to temporary storage and return accessible URL/path\"\"\"\n    try:\n        # Create temporary file\n        temp_dir = tempfile.gettempdir()\n        temp_path = os.path.join(temp_dir, f\"telegram_image_{filename}\")\n        \n        # Write image content to temporary file\n        async with aiofiles.open(temp_path, 'wb') as f:\n            await f.write(image_content)\n        \n        logger.info(f\"Image saved to temporary storage: {temp_path}\")\n        return temp_path\n        \n    except Exception as e:\n        logger.error(f\"Error uploading image to temporary storage: {e}\")\n        return None\n\nasync def send_to_brs_api(prompt: str, model: str, image_path: Optional[str] = None) -> str:\n    \"\"\"Send request to BRS AI API using aiohttp\"\"\"\n    headers = {\n        \"Authorization\": f\"Bearer {BRS_AI_API_KEY}\",\n        \"Content-Type\": \"application/json\"\n    }\n    \n    # Different endpoints and parameters for different models\n    if model.startswith(\"veo3\"):\n        api_url = \"https://api.kie.ai/api/v1/veo/generate\"\n        data = {\n            \"prompt\": prompt,\n            \"model\": model,\n            \"aspectRatio\": \"16:9\",\n            \"enableFallback\": False,\n            \"enableTranslation\": True,\n            \"callBackUrl\": f\"{WEBHOOK_URL.rstrip('/')}/brs_callback\"\n        }\n        # Add image URLs for Veo3 if provided\n        if image_path:\n            # Serve image through our web server\n            image_url = f\"{WEBHOOK_URL}/images/{os.path.basename(image_path)}\"\n            data[\"imageUrls\"] = [image_url]\n            logger.info(f\"Added image URL for Veo3: {image_url}\")\n            \n    elif model == \"runway_gen3\":\n        api_url = \"https://api.kie.ai/api/v1/runway/generate\"\n        data = {\n            \"prompt\": prompt,\n            \"duration\": 5,\n            \"quality\": \"720p\",\n            \"aspectRatio\": \"16:9\",\n            \"model\": \"runway-duration-5-generate\",\n            \"waterMark\": \"\",\n            \"callBackUrl\": f\"{WEBHOOK_URL.rstrip('/')}/brs_callback\"\n        }\n        # Add image URL for Runway if provided\n        if image_path:\n            # Serve image through our web server\n            image_url = f\"{WEBHOOK_URL}/images/{os.path.basename(image_path)}\"\n            data[\"imageUrl\"] = image_url\n            logger.info(f\"Added image URL for Runway: {image_url}\")\n            \n    elif model.startswith(\"wan_2_2\"):\n        api_url = \"https://api.kie.ai/api/v1/jobs/createTask\"\n        \n        # Determine the specific Wan 2.2 model variant\n        if model == \"wan_2_2_t2v\":\n            model_name = \"wan/2-2-a14b-text-to-video-turbo\"\n            input_data = {\n                \"prompt\": prompt,\n                \"resolution\": \"720p\",\n                \"aspect_ratio\": \"16:9\",\n                \"enable_prompt_expansion\": False,\n                \"acceleration\": \"none\"\n            }\n        elif model == \"wan_2_2_i2v\":\n            model_name = \"wan/2-2-a14b-image-to-video-turbo\"\n            input_data = {\n                \"prompt\": prompt,\n                \"resolution\": \"720p\", \n                \"aspect_ratio\": \"auto\",\n                \"enable_prompt_expansion\": False,\n                \"acceleration\": \"none\"\n            }\n            # Add image URL if provided\n            if image_path:\n                # Serve image through our web server\n                image_url = f\"{WEBHOOK_URL}/images/{os.path.basename(image_path)}\"\n                input_data[\"image_url\"] = image_url\n                logger.info(f\"Added image URL for Wan 2.2 I2V: {image_url}\")\n        else:\n            raise Exception(f\"Unknown Wan 2.2 variant: {model}\")\n            \n        data = {\n            \"model\": model_name,\n            \"callBackUrl\": f\"{WEBHOOK_URL.rstrip('/')}/brs_callback\",\n            \"input\": input_data\n        }\n        \n    elif model.startswith(\"kling\"):\n        api_url = \"https://api.kie.ai/api/v1/jobs/createTask\"\n        \n        # Determine the specific Kling model variant\n        if model == \"kling_standard\":\n            model_name = \"kling/v2-1-standard\"\n        elif model == \"kling_pro\":\n            model_name = \"kling/v2-1-pro\"\n        elif model == \"kling_master_i2v\":\n            model_name = \"kling/v2-1-master-image-to-video\"\n        elif model == \"kling_master_t2v\":\n            model_name = \"kling/v2-1-master-text-to-video\"\n        else:\n            raise Exception(f\"Unknown Kling variant: {model}\")\n            \n        # Build input data for Kling models\n        input_data = {\n            \"prompt\": prompt,\n            \"duration\": \"5\",  # 5 seconds default\n            \"aspect_ratio\": \"16:9\",\n            \"negative_prompt\": \"blur, distort, and low quality\",\n            \"cfg_scale\": 0.5\n        }\n        \n        # Add image URL for image-to-video models\n        if model.endswith(\"_i2v\") or model == \"kling_standard\" or model == \"kling_pro\":\n            if image_path:\n                # Serve image through our web server\n                image_url = f\"{WEBHOOK_URL}/images/{os.path.basename(image_path)}\"\n                input_data[\"image_url\"] = image_url\n                logger.info(f\"Added image URL for Kling: {image_url}\")\n                \n        data = {\n            \"model\": model_name,\n            \"callBackUrl\": f\"{WEBHOOK_URL.rstrip('/')}/brs_callback\",\n            \"input\": input_data\n        }\n        \n    elif model.startswith(\"sora_2\"):\n        api_url = \"https://api.kie.ai/api/v1/jobs/createTask\"\n        \n        # Determine the specific Sora 2 model variant\n        if model == \"sora_2_t2v\":\n            model_name = \"sora-2-text-to-video\"\n            input_data = {\n                \"prompt\": prompt,\n                \"aspect_ratio\": \"landscape\",\n                \"quality\": \"standard\"\n            }\n        elif model == \"sora_2_i2v\":\n            model_name = \"sora-2-image-to-video\"\n            input_data = {\n                \"prompt\": prompt,\n                \"aspect_ratio\": \"landscape\",\n                \"quality\": \"standard\"\n            }\n            # Add image URL if provided\n            if image_path:\n                # Serve image through our web server\n                image_url = f\"{WEBHOOK_URL}/images/{os.path.basename(image_path)}\"\n                input_data[\"image_url\"] = image_url\n                logger.info(f\"Added image URL for Sora 2 I2V: {image_url}\")\n        else:\n            raise Exception(f\"Unknown Sora 2 variant: {model}\")\n            \n        data = {\n            \"model\": model_name,\n            \"callBackUrl\": f\"{WEBHOOK_URL.rstrip('/')}/brs_callback\",\n            \"input\": input_data\n        }\n    else:\n        raise Exception(f\"Unsupported model: {model}\")\n    \n    try:\n        global http_session\n        if not http_session:\n            http_session = ClientSession()\n            \n        async with http_session.post(api_url, headers=headers, json=data) as response:\n            if response.status == 200:\n                result = await response.json()\n                # BRS AI returns format: {\"code\": 200, \"msg\": \"success\", \"data\": {\"taskId\": \"...\"}}\n                if result.get(\"code\") == 200 and \"data\" in result:\n                    return result[\"data\"].get(\"taskId\", \"unknown\")\n                else:\n                    raise Exception(f\"BRS Error: {result.get('msg', 'Unknown error')}\")\n            else:\n                error_text = await response.text()\n                raise Exception(f\"BRS Error: HTTP {response.status} - {error_text}\")\n                \n    except Exception as e:\n        logger.error(f\"Error sending to BRS API: {e}\")\n        raise\n\n# Bot command handlers\n@dp.message(Command(\"start\"))\nasync def cmd_start(message: Message):\n    \"\"\"Handle /start command\"\"\"\n    if not message.from_user:\n        return\n        \n    try:\n        user_id = message.from_user.id\n        account_id = get_credit_account_id(message)\n        credits = get_credits(account_id)\n        \n        welcome_text = f\"\"\"\nüé¨ **Welcome to AI Video Generator Bot!**\n\nüëã **Hello {message.from_user.first_name or 'there'}!**\n\nüí≥ **Your Credits:** {credits} {'credit' if credits == 1 else 'credits'}\n\nüöÄ **Quick Start:**\n‚Ä¢ Use /generate to create amazing videos\n‚Ä¢ Need credits? Try /buy for great packages\n‚Ä¢ Get help anytime with /help\n\nüéØ **Available Models:** 7 AI models including Veo 3, Runway Gen-3, Sora 2, and Kling 2.1\n\nüí∞ **Pricing:** 1 credit per video, bulk discounts available\n\n‚ö†Ô∏è **This bot is in BETA - not everything works yet - we are updating daily!**\n\n‚ú® Ready to create something amazing?\n\"\"\"\n        \n        # Create welcome keyboard with quick actions\n        welcome_keyboard = InlineKeyboardMarkup(inline_keyboard=[\n            [InlineKeyboardButton(text=\"üé¨ Generate Video\", callback_data=\"quick_generate\")],\n            [InlineKeyboardButton(text=\"üí≥ Buy Credits\", callback_data=\"show_packages\"),\n             InlineKeyboardButton(text=\"‚ùì Help & Guide\", callback_data=\"help_main\")],\n            [InlineKeyboardButton(text=\"üìä My Stats\", callback_data=\"user_stats\")]\n        ])\n        \n        await message.answer(welcome_text, reply_markup=welcome_keyboard, parse_mode=\"Markdown\")\n        \n    except Exception as e:\n        logger.error(f\"Error in cmd_start: {e}\")\n        await message.answer(\"‚ùå An error occurred. Please try again later.\")\n\n@dp.message(Command(\"reset\"))\nasync def cmd_reset(message: Message, state: FSMContext):\n    \"\"\"Handle /reset command to clear model selection and state\"\"\"\n    if not message.from_user:\n        return\n        \n    try:\n        user_id = message.from_user.id\n        \n        # Clear selected model\n        if user_id in user_models:\n            del user_models[user_id]\n            \n        # Clear FSM state\n        await state.clear()\n        \n        account_id = get_credit_account_id(message)\n        credits = get_credits(account_id)\n        \n        await message.answer(\n            \"üîÑ **Reset Complete!**\\n\\n\"\n            f\"üí≥ **Your Balance:** `{credits}` credits\\n\\n\"\n            \"‚úÖ **Cleared:**\\n\"\n            \"‚Ä¢ Selected AI model\\n\"\n            \"‚Ä¢ Any pending inputs\\n\"\n            \"‚Ä¢ Generation state\\n\\n\"\n            \"üé¨ **Ready for a fresh start!**\\n\"\n            \"Use /generate to begin creating videos\",\n            parse_mode=\"Markdown\"\n        )\n        \n    except Exception as e:\n        logger.error(f\"Error in cmd_reset: {e}\")\n        await message.answer(\"‚ùå An error occurred during reset. Please try again.\")\n\n@dp.message(Command(\"video\"))\nasync def cmd_send_video(message: Message):\n    \"\"\"Manually send the last generated video that wasn't delivered\"\"\"\n    if not message.from_user:\n        return\n        \n    try:\n        user_id = message.from_user.id\n        \n        # Send the video that was generated but not delivered\n        video_url = \"https://tempfile.aiquickdraw.com/p/3fc297d0f7ad7c3c0680d94dc3ae5ee8_1758925534.mp4\"\n        \n        await bot.send_message(\n            chat_id=user_id,\n            text=f\"üé¨ **Your Previous Video is Ready!**\\n\\n\"\n                 f\"üìπ **Video URL:** {video_url}\\n\\n\"\n                 f\"ü¶ù *The raccoon in a suit turns to the camera and says \\\"BRS Studio is now live on Telegram!\\\"*\\n\\n\"\n                 f\"üí° This was the video that was successfully generated but not delivered due to a callback parsing issue (now fixed).\",\n            parse_mode=\"Markdown\"\n        )\n        \n        # Try to send as actual video file too\n        try:\n            global http_session\n            if not http_session:\n                http_session = ClientSession()\n                \n            async with http_session.get(video_url) as response:\n                if response.status == 200:\n                    video_content = await response.read()\n                    video_file = BufferedInputFile(video_content, filename=\"raccoon_brs_studio.mp4\")\n                    \n                    await bot.send_video(\n                        chat_id=user_id,\n                        video=video_file,\n                        caption=\"üé¨ Your video is ready! (Previously generated)\"\n                    )\n        except Exception as video_error:\n            logger.error(f\"Could not send video file: {video_error}\")\n        \n    except Exception as e:\n        logger.error(f\"Error in cmd_send_video: {e}\")\n        await message.answer(\"‚ùå Could not retrieve the previous video.\")\n\n@dp.message(Command(\"generate\"))\nasync def cmd_generate(message: Message, state: FSMContext):\n    \"\"\"Handle /generate command\"\"\"\n    if not message.from_user:\n        return\n        \n    try:\n        user_id = message.from_user.id\n        account_id = get_credit_account_id(message)\n        credits = get_credits(account_id)\n        is_group = is_group_chat(message)\n        \n        # For groups, delete the command message to reduce clutter\n        if is_group:\n            try:\n                await bot.delete_message(chat_id=message.chat.id, message_id=message.message_id)\n                logger.info(f\"Deleted command message {message.message_id} in group {message.chat.id}\")\n            except Exception as e:\n                logger.warning(f\"Could not delete command message: {e}\")\n        \n        if credits < 1:\n            no_credits_keyboard = InlineKeyboardMarkup(inline_keyboard=[\n                [InlineKeyboardButton(text=\"üí≥ Buy Credits\", callback_data=\"buy_credits\")],\n                [InlineKeyboardButton(text=\"üìö Learn More\", callback_data=\"help_credits\")]\n            ])\n            response_msg = await message.answer(\n                \"üí∏ **Insufficient Credits!**\\n\\n\"\n                f\"üí≥ **Current Balance:** `{credits}` credits\\n\\n\"\n                \"üé¨ **Required:** `1` credit for video generation\\n\\n\"\n                \"üí° **Quick Solutions:**\\n\"\n                \"‚Ä¢ Buy credits with Telegram Stars (‚≠ê)\\n\"\n                \"‚Ä¢ 100 Stars = 1 Credit (‚âà $1.30)\\n\\n\"\n                \"üëÜ **Tap below to get started!**\",\n                reply_markup=no_credits_keyboard,\n                parse_mode=\"Markdown\"\n            )\n            return\n        \n        # Check if user has a selected model\n        if user_id not in user_models:\n            keyboard = create_model_selection_keyboard()\n            response_msg = await message.answer(\n                \"ü§ñ **Choose Your AI Model**\\n\\n\"\n                f\"üí≥ **Your Balance:** `{credits}` credits\\n\\n\"\n                \"üéØ **Select the perfect model for your video:**\\n\\n\"\n                \"‚ö° **Fast:** Quick generation (1-2 min)\\n\"\n                \"üéµ **Audio:** High quality with sound\\n\"\n                \"üöÄ **Advanced:** Premium features\\n\"\n                \"üí∞ **Affordable:** Budget-friendly options\\n\\n\"\n                \"üëÜ **Tap a model below to continue:**\",\n                reply_markup=keyboard,\n                parse_mode=\"Markdown\"\n            )\n            return\n        \n        # User has a model, ask for prompt\n        selected_model = user_models[user_id]\n        model_name = AVAILABLE_MODELS[selected_model]\n        \n        # Check if model supports image-to-video\n        image_models = [\"wan_2_2_i2v\", \"kling_standard\", \"kling_pro\", \"kling_master_i2v\", \"veo3_fast\", \"runway_gen3\"]\n        supports_images = selected_model in image_models\n        \n        prompt_hint = \" - you can add an image in step 2\" if supports_images else \"\"\n        \n        # In groups, use simplified flow, in private chats use full interactive flow\n        if is_group:\n            # For groups, show a simple message and wait for next user input\n            response_msg = await message.answer(\n                f\"ü§ñ **{model_name}** selected\\n\"\n                f\"üìù **Reply with your video prompt:**\\n\\n\"\n                \"üí° *Be descriptive: actions, emotions, camera angles*\",\n                parse_mode=\"Markdown\"\n            )\n        else:\n            # Private chat gets full detailed instructions\n            response_msg = await message.answer(\n                f\"‚ú® **Model Selected:** {model_name}\\n\"\n                \"üîÑ `/reset` to start over\\n\\n\"\n                f\"üí≥ **Your Balance:** `{credits}` credits\\n\\n\"\n                f\"üìù **Step 1:** Enter your creative prompt{prompt_hint}\\n\\n\"\n                \"üí° **Pro Tips:**\\n\"\n                \"‚Ä¢ Be specific and descriptive\\n\"\n                \"‚Ä¢ Mention camera angles, lighting, mood\\n\"\n                \"‚Ä¢ Keep it under 500 characters\\n\\n\"\n                \"üé¨ **Example:** *A majestic eagle soaring over snow-capped mountains at sunset*\\n\\n\"\n                \"‚úçÔ∏è **Your turn - type your prompt below:**\",\n                parse_mode=\"Markdown\"\n            )\n        \n        await state.set_state(GenerationStates.waiting_for_prompt)\n        \n    except Exception as e:\n        logger.error(f\"Error in cmd_generate: {e}\")\n        await message.answer(\"‚ùå An error occurred. Please try again later.\")\n\n@dp.callback_query(F.data.startswith(\"model_\"))\nasync def process_model_selection(callback: CallbackQuery, state: FSMContext):\n    \"\"\"Handle model selection\"\"\"\n    if not callback.from_user or not callback.data:\n        return\n        \n    try:\n        user_id = callback.from_user.id\n        model_key = callback.data.split(\"_\", 1)[1]\n        \n        if model_key in AVAILABLE_MODELS:\n            user_models[user_id] = model_key\n            save_user_models()  # Persist model selection\n            model_name = AVAILABLE_MODELS[model_key]\n            \n            if callback.message and hasattr(callback.message, 'edit_text'):\n                try:\n                    await callback.message.edit_text(  # type: ignore\n                        f\"‚úÖ Model selected: {model_name}\\n\\n\"\n                        \"üìù Please enter your text prompt for video generation:\"\n                    )\n                except Exception as e:\n                    # If editing fails, send a new message\n                    await bot.send_message(\n                        callback.from_user.id,\n                        f\"‚úÖ Model selected: {model_name}\\n\\n\"\n                        \"üìù Please enter your text prompt for video generation:\"\n                    )\n            elif callback.message:\n                # Message exists but doesn't support editing, send new message\n                await bot.send_message(\n                    callback.from_user.id,\n                    f\"‚úÖ Model selected: {model_name}\\n\\n\"\n                    \"üìù Please enter your text prompt for video generation:\"\n                )\n            await state.set_state(GenerationStates.waiting_for_prompt)\n        \n        await callback.answer()\n        \n    except Exception as e:\n        logger.error(f\"Error in process_model_selection: {e}\")\n        await callback.answer(\"‚ùå An error occurred. Please try again later.\")\n\n# New comprehensive callback handlers for enhanced UI\n@dp.callback_query(F.data == \"quick_generate\")\nasync def quick_generate_callback(callback: CallbackQuery, state: FSMContext):\n    \"\"\"Handle quick generate button from welcome and other menus\"\"\"\n    if not callback.from_user:\n        return\n    \n    try:\n        user_id = callback.from_user.id\n        account_id = get_callback_account_id(callback)\n        credits = get_credits(account_id)\n        \n        if credits < 1:\n            no_credits_keyboard = InlineKeyboardMarkup(inline_keyboard=[\n                [InlineKeyboardButton(text=\"üí≥ Buy Credits\", callback_data=\"buy_credits\")],\n                [InlineKeyboardButton(text=\"üìö Learn More\", callback_data=\"help_credits\")]\n            ])\n            await safe_edit_message(\n                callback,\n                \"üí∏ **Insufficient Credits!**\\n\\n\"\n                f\"üí≥ **Current Balance:** `{credits}` credits\\n\\n\"\n                \"üé¨ **Required:** `1` credit for video generation\\n\\n\"\n                \"üí° **Quick Solutions:**\\n\"\n                \"‚Ä¢ Buy credits with Telegram Stars (‚≠ê)\\n\"\n                \"‚Ä¢ 100 Stars = 1 Credit (‚âà $1.30)\\n\\n\"\n                \"üëÜ **Tap below to get started!**\",\n                no_credits_keyboard\n            )\n            await callback.answer()\n            return\n        \n        # Check if user has a selected model\n        if user_id not in user_models:\n            keyboard = create_model_selection_keyboard()\n            await safe_edit_message(\n                callback,\n                \"ü§ñ **Choose Your AI Model**\\n\\n\"\n                f\"üí≥ **Your Balance:** `{credits}` credits\\n\\n\"\n                \"üéØ **Select the perfect model for your video:**\\n\\n\"\n                \"‚ö° **Fast:** Quick generation (1-2 min)\\n\"\n                \"üéµ **Audio:** High quality with sound\\n\"\n                \"üöÄ **Advanced:** Premium features\\n\"\n                \"üí∞ **Affordable:** Budget-friendly options\\n\\n\"\n                \"üëÜ **Tap a model below to continue:**\",\n                keyboard\n            )\n            await callback.answer()\n            return\n        \n        # User has a model, ask for prompt\n        selected_model = user_models[user_id]\n        model_name = AVAILABLE_MODELS[selected_model]\n        \n        # Check if model supports image-to-video\n        image_models = [\"wan_2_2_i2v\", \"kling_standard\", \"kling_pro\", \"kling_master_i2v\", \"veo3_fast\", \"runway_gen3\"]\n        supports_images = selected_model in image_models\n        \n        prompt_hint = \" - you can add an image in step 2\" if supports_images else \"\"\n        \n        await safe_edit_message(\n            callback,\n            f\"‚ú® **Model Selected:** {model_name}\\n\"\n            \"üîÑ `/reset` to start over\\n\\n\"\n            f\"üí≥ **Your Balance:** `{credits}` credits\\n\\n\"\n            f\"üìù **Step 1:** Enter your creative prompt{prompt_hint}\\n\\n\"\n            \"üí° **Pro Tips:**\\n\"\n            \"‚Ä¢ Be specific and descriptive\\n\"\n            \"‚Ä¢ Mention camera angles, lighting, mood\\n\"\n            \"‚Ä¢ Keep it under 500 characters\\n\\n\"\n            \"üé¨ **Example:** *A majestic eagle soaring over snow-capped mountains at sunset*\\n\\n\"\n            \"‚úçÔ∏è **Your turn - type your prompt below:\"\n        )\n        await state.set_state(GenerationStates.waiting_for_prompt)\n        await callback.answer()\n        \n    except Exception as e:\n        logger.error(f\"Error in quick_generate_callback: {e}\")\n        await callback.answer(\"‚ùå Error starting generation. Please try again.\")\n\n@dp.callback_query(F.data == \"buy_credits\")\nasync def buy_credits_callback(callback: CallbackQuery):\n    \"\"\"Handle buy credits button\"\"\"\n    if not callback.from_user:\n        return\n        \n    try:\n        user_id = callback.from_user.id\n        account_id = get_callback_account_id(callback)\n        credits = get_credits(account_id)\n        \n        # Create enhanced buy menu\n        buy_keyboard = InlineKeyboardMarkup(inline_keyboard=[\n            [InlineKeyboardButton(text=\"‚≠ê Buy 1 Credit (100 Stars)\", callback_data=\"buy_package_100\")],\n            [InlineKeyboardButton(text=\"üìä Credit Packages\", callback_data=\"buy_packages\")],\n            [InlineKeyboardButton(text=\"üí° How Stars Work\", callback_data=\"help_stars\")],\n            [InlineKeyboardButton(text=\"üîô Back to Menu\", callback_data=\"back_main\")]\n        ])\n        \n        buy_text = (\n            \"üí≥ **Credit Store**\\n\\n\"\n            f\"üí∞ **Current Balance:** `{credits}` {'credit' if credits == 1 else 'credits'}\\n\\n\"\n            \"‚≠ê **Telegram Stars Pricing:**\\n\"\n            \"‚Ä¢ 1 Credit = 100 Stars (‚âà $1.30)\\n\"\n            \"‚Ä¢ Instant delivery\\n\"\n            \"‚Ä¢ Secure Telegram payment\\n\\n\"\n            \"üé¨ **What you get:**\\n\"\n            \"‚Ä¢ Generate 1 high-quality AI video\\n\"\n            \"‚Ä¢ Choice of 5 premium models\\n\"\n            \"‚Ä¢ Image-to-video support\\n\"\n            \"‚Ä¢ Direct delivery to Telegram\\n\\n\"\n            \"üí° **Tip:** Credits never expire, bulk discounts available!\"\n        )\n        \n        await safe_edit_message(callback, buy_text, reply_markup=buy_keyboard, parse_mode=\"Markdown\")\n        \n        await callback.answer()\n        \n    except Exception as e:\n        logger.error(f\"Error in buy_credits_callback: {e}\")\n        await callback.answer(\"‚ùå Error loading credit store.\")\n\n@dp.callback_query(F.data == \"buy_1\")\nasync def buy_one_credit_callback(callback: CallbackQuery):\n    \"\"\"Handle buying 1 credit\"\"\"\n    if not callback.from_user:\n        return\n        \n    try:\n        # Simulate the /buy command\n        if callback.message:\n            await cmd_buy(callback.message)\n        await callback.answer(\"üõí Opening payment...\")\n        \n    except Exception as e:\n        logger.error(f\"Error in buy_one_credit_callback: {e}\")\n        await callback.answer(\"‚ùå Error processing purchase.\")\n\n@dp.callback_query(F.data == \"user_stats\")\nasync def user_stats_callback(callback: CallbackQuery):\n    \"\"\"Show user statistics and account info\"\"\"\n    if not callback.from_user:\n        return\n        \n    try:\n        user_id = callback.from_user.id\n        account_id = get_callback_account_id(callback)\n        credits = get_credits(account_id)\n        user_name = callback.from_user.first_name or \"User\"\n        \n        # Count pending generations for this user\n        user_pending = sum(1 for gen in pending_generations.values() if gen.get('user_id') == user_id)\n        \n        stats_keyboard = InlineKeyboardMarkup(inline_keyboard=[\n            [InlineKeyboardButton(text=\"üé¨ Generate Video\", callback_data=\"quick_generate\")],\n            [InlineKeyboardButton(text=\"üí≥ Buy Credits\", callback_data=\"buy_credits\")],\n            [InlineKeyboardButton(text=\"üîô Main Menu\", callback_data=\"back_main\")]\n        ])\n        \n        stats_text = (\n            f\"üìä **Account Statistics**\\n\\n\"\n            f\"üë§ **User:** {user_name}\\n\"\n            f\"üÜî **ID:** `{user_id}`\\n\\n\"\n            f\"üí≥ **Credits:** `{credits}` {'credit' if credits == 1 else 'credits'}\\n\"\n            f\"‚è≥ **Pending:** `{user_pending}` {'generation' if user_pending == 1 else 'generations'}\\n\\n\"\n            \"üéØ **Usage Tips:**\\n\"\n            \"‚Ä¢ Each video costs 1 credit\\n\"\n            \"‚Ä¢ Credits never expire\\n\"\n            \"‚Ä¢ Try different models for variety\\n\\n\"\n            \"üöÄ **Ready for your next creation?**\"\n        )\n        \n        await safe_edit_message(callback, stats_text, reply_markup=stats_keyboard, parse_mode=\"Markdown\")\n        \n        await callback.answer()\n        \n    except Exception as e:\n        logger.error(f\"Error in user_stats_callback: {e}\")\n        await callback.answer(\"‚ùå Error loading stats.\")\n\n@dp.callback_query(F.data == \"help_main\")\nasync def help_main_callback(callback: CallbackQuery):\n    \"\"\"Show main help menu\"\"\"\n    if not callback.from_user:\n        return\n        \n    try:\n        help_keyboard = InlineKeyboardMarkup(inline_keyboard=[\n            [InlineKeyboardButton(text=\"üé¨ Video Generation\", callback_data=\"help_generate\")],\n            [InlineKeyboardButton(text=\"üí≥ Credits & Payment\", callback_data=\"help_credits\")],\n            [InlineKeyboardButton(text=\"ü§ñ AI Models Guide\", callback_data=\"help_models\")],\n            [InlineKeyboardButton(text=\"üñºÔ∏è Image Upload Tips\", callback_data=\"help_image\")],\n            [InlineKeyboardButton(text=\"üõ†Ô∏è Troubleshooting\", callback_data=\"help_troubleshoot\")],\n            [InlineKeyboardButton(text=\"üîô Main Menu\", callback_data=\"back_main\")]\n        ])\n        \n        help_text = (\n            \"‚ùì **Help & Support Center**\\n\\n\"\n            \"Welcome to the comprehensive help system! Choose a topic below to get detailed assistance:\\n\\n\"\n            \"üé¨ **Video Generation** - Learn how to create videos\\n\"\n            \"üí≥ **Credits & Payment** - Understand the credit system\\n\"\n            \"ü§ñ **AI Models** - Compare different models\\n\"\n            \"üñºÔ∏è **Image Tips** - Optimize your image uploads\\n\"\n            \"üõ†Ô∏è **Troubleshooting** - Fix common issues\\n\\n\"\n            \"üí¨ **Need more help?** Contact @niftysolsol\"\n        )\n        \n        await safe_edit_message(callback, help_text, reply_markup=help_keyboard, parse_mode=\"Markdown\")\n        \n        await callback.answer()\n        \n    except Exception as e:\n        logger.error(f\"Error in help_main_callback: {e}\")\n        await callback.answer(\"‚ùå Error loading help.\")\n\n@dp.callback_query(F.data == \"skip_image\")\nasync def skip_image_callback(callback: CallbackQuery, state: FSMContext):\n    \"\"\"Handle skip image button during generation\"\"\"\n    if not callback.from_user:\n        return\n        \n    try:\n        # Simulate typing 'skip'\n        data = await state.get_data()\n        if data.get('prompt'):\n            # Create a mock message with 'skip' text that includes the necessary properties for cleanup\n            class MockMessage:\n                def __init__(self, user, text, chat, message_id):\n                    self.from_user = user\n                    self.text = text\n                    self.photo = None\n                    self.chat = chat\n                    self.message_id = message_id\n                \n                async def answer(self, text, **kwargs):\n                    # Send message through callback query instead\n                    try:\n                        if callback.message:\n                            return await callback.message.answer(text, **kwargs)\n                        else:\n                            logger.error(\"Callback message is None\")\n                            return None\n                    except Exception as e:\n                        logger.error(f\"Failed to send mock message answer: {e}\")\n                        return None\n            \n            # Use callback message properties for the mock message\n            mock_message = MockMessage(\n                callback.from_user, \n                'skip',\n                callback.message.chat if callback.message else None,\n                callback.message.message_id if callback.message else 0\n            )\n            await process_image_or_skip(mock_message, state)\n        \n        await callback.answer(\"‚è≠Ô∏è Skipping image upload...\")\n        \n    except Exception as e:\n        logger.error(f\"Error in skip_image_callback: {e}\")\n        await callback.answer(\"‚ùå Error processing skip.\")\n\n# Additional help system callbacks\n@dp.callback_query(F.data == \"help_generate\")\nasync def help_generate_callback(callback: CallbackQuery):\n    \"\"\"Show video generation help\"\"\"\n    if not callback.from_user:\n        return\n    \n    try:\n        back_keyboard = InlineKeyboardMarkup(inline_keyboard=[\n            [InlineKeyboardButton(text=\"üé¨ Try Now\", callback_data=\"quick_generate\")],\n            [InlineKeyboardButton(text=\"ü§ñ Model Guide\", callback_data=\"help_models\")],\n            [InlineKeyboardButton(text=\"üîô Help Menu\", callback_data=\"help_main\")]\n        ])\n        \n        help_text = (\n            \"üé¨ **Video Generation Guide**\\n\\n\"\n            \"üöÄ **Getting Started:**\\n\"\n            \"1Ô∏è‚É£ Use `/generate` or tap Generate Video\\n\"\n            \"2Ô∏è‚É£ Choose from 9 AI models\\n\"\n            \"3Ô∏è‚É£ Write a creative prompt (be specific!)\\n\"\n            \"4Ô∏è‚É£ Upload image (optional)\\n\"\n            \"5Ô∏è‚É£ Wait 2-5 minutes for your video\\n\\n\"\n            \"‚úçÔ∏è **Writing Great Prompts:**\\n\"\n            \"‚Ä¢ Be specific and descriptive\\n\"\n            \"‚Ä¢ Include camera angles, lighting, mood\\n\"\n            \"‚Ä¢ Mention colors, movement, style\\n\"\n            \"‚Ä¢ Keep under 500 characters\\n\\n\"\n            \"üåü **Example Prompts:**\\n\"\n            \"_\\\"A majestic golden eagle soaring over snow-capped mountains at sunset, cinematic wide shot\\\"_\\n\\n\"\n            \"_\\\"Close-up of raindrops on a car window, neon city lights blurred in background, moody lighting\\\"_\\n\\n\"\n            \"üí∞ **Cost:** 1 credit per video (‚âà $1.30)\"\n        )\n        \n        await safe_edit_message(callback, help_text, reply_markup=back_keyboard, parse_mode=\"Markdown\")\n        \n        await callback.answer()\n        \n    except Exception as e:\n        logger.error(f\"Error in help_generate_callback: {e}\")\n        await callback.answer(\"‚ùå Error loading help.\")\n\n@dp.callback_query(F.data == \"help_credits\")\nasync def help_credits_callback(callback: CallbackQuery):\n    \"\"\"Show credits and payment help\"\"\"\n    if not callback.from_user:\n        return\n    \n    try:\n        credits_keyboard = InlineKeyboardMarkup(inline_keyboard=[\n            [InlineKeyboardButton(text=\"‚≠ê Buy Credits\", callback_data=\"buy_credits\")],\n            [InlineKeyboardButton(text=\"üìä Check Balance\", callback_data=\"user_stats\")],\n            [InlineKeyboardButton(text=\"üîô Help Menu\", callback_data=\"help_main\")]\n        ])\n        \n        help_text = (\n            \"üí≥ **Credits & Payment Guide**\\n\\n\"\n            \"üí∞ **Credit System:**\\n\"\n            \"‚Ä¢ 1 Credit = 1 Video Generation\\n\"\n            \"‚Ä¢ Credits never expire\\n\"\n            \"‚Ä¢ Refunded if generation fails\\n\"\n            \"‚Ä¢ Track balance anytime\\n\\n\"\n            \"‚≠ê **Telegram Stars Payment:**\\n\"\n            \"‚Ä¢ 1 Credit = 100 Stars (‚âà $1.30)\\n\"\n            \"‚Ä¢ Secure Telegram payment system\\n\"\n            \"‚Ä¢ Instant credit delivery\\n\"\n            \"‚Ä¢ No external payment needed\\n\\n\"\n            \"üõí **How to Buy:**\\n\"\n            \"1Ô∏è‚É£ Tap 'Buy Credits' button\\n\"\n            \"2Ô∏è‚É£ Confirm 100 Stars payment\\n\"\n            \"3Ô∏è‚É£ Credits added instantly\\n\"\n            \"4Ô∏è‚É£ Start generating videos!\\n\\n\"\n            \"üîí **Security:** All payments processed by Telegram\\n\"\n            \"üíµ **Pricing:** Competitive rates, no hidden fees\"\n        )\n        \n        await safe_edit_message(callback, help_text, reply_markup=credits_keyboard, parse_mode=\"Markdown\")\n        \n        await callback.answer()\n        \n    except Exception as e:\n        logger.error(f\"Error in help_credits_callback: {e}\")\n        await callback.answer(\"‚ùå Error loading help.\")\n\n@dp.callback_query(F.data == \"help_models\")\nasync def help_models_callback(callback: CallbackQuery):\n    \"\"\"Show AI models comparison help\"\"\"\n    if not callback.from_user:\n        return\n    \n    try:\n        models_keyboard = InlineKeyboardMarkup(inline_keyboard=[\n            [InlineKeyboardButton(text=\"üé¨ Generate Video\", callback_data=\"quick_generate\")],\n            [InlineKeyboardButton(text=\"üìù Generation Guide\", callback_data=\"help_generate\")],\n            [InlineKeyboardButton(text=\"üîô Help Menu\", callback_data=\"help_main\")]\n        ])\n        \n        help_text = (\n            \"ü§ñ **AI Models Comparison**\\n\\n\"\n            \"‚ö° **Veo 3 Fast** - Quick generation (1-2 min)\\n\"\n            \"‚Ä¢ Best for: Fast results\\n\"\n            \"‚Ä¢ Quality: Good\\n\"\n            \"‚Ä¢ Features: Speed optimized\\n\\n\"\n            \"üéµ **Veo 3** - High quality with audio\\n\"\n            \"‚Ä¢ Best for: Premium videos with sound\\n\"\n            \"‚Ä¢ Quality: Excellent\\n\"\n            \"‚Ä¢ Features: Synchronized audio\\n\\n\"\n            \"üöÄ **Runway Gen-3** - Advanced video\\n\"\n            \"‚Ä¢ Best for: Complex scenes\\n\"\n            \"‚Ä¢ Quality: Professional\\n\"\n            \"‚Ä¢ Features: Advanced reasoning\\n\\n\"\n            \"üìù **Wan 2.2 T2V** - Text to video\\n\"\n            \"‚Ä¢ Best for: Text-only prompts\\n\"\n            \"‚Ä¢ Quality: High\\n\"\n            \"‚Ä¢ Features: Pure text generation\\n\\n\"\n            \"üñºÔ∏è **Wan 2.2 I2V** - Image to video\\n\"\n            \"‚Ä¢ Best for: Animating images\\n\"\n            \"‚Ä¢ Quality: High\\n\"\n            \"‚Ä¢ Features: Image animation\\n\\n\"\n            \"üí∞ **Kling Standard** - Affordable 720p\\n\"\n            \"‚Ä¢ Best for: Budget-conscious users\\n\"\n            \"‚Ä¢ Quality: Good (720p)\\n\"\n            \"‚Ä¢ Features: Cost-effective\\n\\n\"\n            \"‚≠ê **Kling Pro** - Enhanced 1080p\\n\"\n            \"‚Ä¢ Best for: High resolution needs\\n\"\n            \"‚Ä¢ Quality: Excellent (1080p)\\n\"\n            \"‚Ä¢ Features: Enhanced quality\\n\\n\"\n            \"üëë **Kling Master I2V** - Premium image-to-video\\n\"\n            \"‚Ä¢ Best for: Professional image animation\\n\"\n            \"‚Ä¢ Quality: Premium\\n\"\n            \"‚Ä¢ Features: Advanced I2V processing\\n\\n\"\n            \"üé¨ **Kling Master T2V** - Premium text-to-video\\n\"\n            \"‚Ä¢ Best for: Professional text generation\\n\"\n            \"‚Ä¢ Quality: Premium\\n\"\n            \"‚Ä¢ Features: Advanced T2V processing\"\n        )\n        \n        await safe_edit_message(callback, help_text, reply_markup=models_keyboard, parse_mode=\"Markdown\")\n        \n        await callback.answer()\n        \n    except Exception as e:\n        logger.error(f\"Error in help_models_callback: {e}\")\n        await callback.answer(\"‚ùå Error loading help.\")\n\n@dp.callback_query(F.data == \"help_image\")\nasync def help_image_callback(callback: CallbackQuery):\n    \"\"\"Show image upload tips\"\"\"\n    if not callback.from_user:\n        return\n    \n    try:\n        image_keyboard = InlineKeyboardMarkup(inline_keyboard=[\n            [InlineKeyboardButton(text=\"üñºÔ∏è Try I2V Models\", callback_data=\"quick_generate\")],\n            [InlineKeyboardButton(text=\"ü§ñ Model Guide\", callback_data=\"help_models\")],\n            [InlineKeyboardButton(text=\"üîô Help Menu\", callback_data=\"help_main\")]\n        ])\n        \n        help_text = (\n            \"üñºÔ∏è **Image Upload Guide**\\n\\n\"\n            \"üì∏ **Supported Formats:**\\n\"\n            \"‚Ä¢ JPG, JPEG, PNG, WebP, GIF\\n\"\n            \"‚Ä¢ Maximum size: 20MB\\n\"\n            \"‚Ä¢ Recommended: 1024x1024+ pixels\\n\\n\"\n            \"üéØ **Best Results:**\\n\"\n            \"‚Ä¢ High resolution images\\n\"\n            \"‚Ä¢ Clear, well-lit photos\\n\"\n            \"‚Ä¢ Good contrast and composition\\n\"\n            \"‚Ä¢ Avoid blurry or dark images\\n\\n\"\n            \"üí° **Pro Tips:**\\n\"\n            \"‚Ä¢ Images work best with I2V models\\n\"\n            \"‚Ä¢ Portrait or landscape both work\\n\"\n            \"‚Ä¢ Add descriptive prompts for context\\n\"\n            \"‚Ä¢ You can skip images for text-only\\n\\n\"\n            \"ü§ñ **Compatible Models:**\\n\"\n            \"‚Ä¢ Wan 2.2 I2V - Image to video\\n\"\n            \"‚Ä¢ Kling Standard - Supports images\\n\"\n            \"‚Ä¢ Kling Pro - Enhanced with images\\n\"\n            \"‚Ä¢ Kling Master I2V - Premium I2V\\n\"\n            \"‚Ä¢ Veo 3 - Image enhancement\\n\"\n            \"‚Ä¢ Runway Gen-3 - Advanced I2V\\n\\n\"\n            \"‚ö†Ô∏è **Note:** Image processing may add 30-60 seconds\"\n        )\n        \n        await safe_edit_message(callback, help_text, reply_markup=image_keyboard, parse_mode=\"Markdown\")\n        \n        await callback.answer()\n        \n    except Exception as e:\n        logger.error(f\"Error in help_image_callback: {e}\")\n        await callback.answer(\"‚ùå Error loading help.\")\n\n@dp.callback_query(F.data == \"help_troubleshoot\")\nasync def help_troubleshoot_callback(callback: CallbackQuery):\n    \"\"\"Show troubleshooting help\"\"\"\n    if not callback.from_user:\n        return\n    \n    try:\n        trouble_keyboard = InlineKeyboardMarkup(inline_keyboard=[\n            [InlineKeyboardButton(text=\"üé¨ Try Again\", callback_data=\"quick_generate\")],\n            [InlineKeyboardButton(text=\"üë§ Contact Support\", callback_data=\"help_contact\")],\n            [InlineKeyboardButton(text=\"üîô Help Menu\", callback_data=\"help_main\")]\n        ])\n        \n        help_text = (\n            \"üõ†Ô∏è **Troubleshooting Guide**\\n\\n\"\n            \"‚ùå **Generation Failed?**\\n\"\n            \"‚Ä¢ Check your prompt clarity\\n\"\n            \"‚Ä¢ Try a different model\\n\"\n            \"‚Ä¢ Ensure stable internet\\n\"\n            \"‚Ä¢ Credits are auto-refunded\\n\\n\"\n            \"üì∏ **Image Issues?**\\n\"\n            \"‚Ä¢ Use supported formats (JPG, PNG)\\n\"\n            \"‚Ä¢ Keep under 20MB size\\n\"\n            \"‚Ä¢ Ensure good image quality\\n\"\n            \"‚Ä¢ Try skipping image if problems persist\\n\\n\"\n            \"‚è±Ô∏è **Taking Too Long?**\\n\"\n            \"‚Ä¢ Normal time: 2-5 minutes\\n\"\n            \"‚Ä¢ Complex prompts take longer\\n\"\n            \"‚Ä¢ High-quality models need more time\\n\"\n            \"‚Ä¢ You'll get notified when ready\\n\\n\"\n            \"üí≥ **Credit Problems?**\\n\"\n            \"‚Ä¢ Check balance with /start\\n\"\n            \"‚Ä¢ Failed generations are refunded\\n\"\n            \"‚Ä¢ Stars payment is instant\\n\"\n            \"‚Ä¢ Contact support if issues persist\\n\\n\"\n            \"üîÑ **General Tips:**\\n\"\n            \"‚Ä¢ Restart with /start\\n\"\n            \"‚Ä¢ Try different prompts\\n\"\n            \"‚Ä¢ Use simpler descriptions\\n\"\n            \"‚Ä¢ Contact support for persistent issues\"\n        )\n        \n        await safe_edit_message(callback, help_text, reply_markup=trouble_keyboard, parse_mode=\"Markdown\")\n        \n        await callback.answer()\n        \n    except Exception as e:\n        logger.error(f\"Error in help_troubleshoot_callback: {e}\")\n        await callback.answer(\"‚ùå Error loading help.\")\n\n@dp.callback_query(F.data == \"back_main\")\nasync def back_main_callback(callback: CallbackQuery):\n    \"\"\"Return to main menu\"\"\"\n    if not callback.from_user:\n        return\n    \n    try:\n        # Simulate /start command\n        if callback.message:\n            await cmd_start(callback.message)\n        await callback.answer(\"üè† Returning to main menu...\")\n        \n    except Exception as e:\n        logger.error(f\"Error in back_main_callback: {e}\")\n        await callback.answer(\"‚ùå Error returning to menu.\")\n\n# Credit package callbacks\n@dp.callback_query(F.data == \"show_packages\")\nasync def show_packages_callback(callback: CallbackQuery):\n    \"\"\"Show credit packages when Buy Credits button is clicked\"\"\"\n    await callback.answer()\n    \n    if not callback.from_user:\n        return\n        \n    try:\n        user_id = callback.from_user.id\n        account_id = get_callback_account_id(callback)\n        credits = get_credits(account_id)\n        \n        # Create credit packages keyboard\n        packages_keyboard = InlineKeyboardMarkup(inline_keyboard=[\n            [InlineKeyboardButton(text=\"üéØ Starter: 100‚≠ê ‚Üí 1 Credit\", callback_data=\"buy_package_100\")],\n            [InlineKeyboardButton(text=\"üî• Popular: 1000‚≠ê ‚Üí 12 Credits\", callback_data=\"buy_package_1000\")],\n            [InlineKeyboardButton(text=\"üíé Best Value: 2000‚≠ê ‚Üí 25 Credits\", callback_data=\"buy_package_2000\")],\n            [InlineKeyboardButton(text=\"üöÄ Premium: 5000‚≠ê ‚Üí 75 Credits\", callback_data=\"buy_package_5000\")],\n            [InlineKeyboardButton(text=\"üëë Ultimate: 10000‚≠ê ‚Üí 175 Credits\", callback_data=\"buy_package_10000\")],\n            [InlineKeyboardButton(text=\"üîô Back to Menu\", callback_data=\"back_to_start\")]\n        ])\n        \n        package_text = (\n            \"‚≠ê **Credit Packages - Telegram Stars**\\n\\n\"\n            f\"üí≥ **Current Balance:** {credits} credits\\n\\n\"\n            \"üéØ **Starter Package**\\n\"\n            \"‚Ä¢ 100 Stars ‚Üí 1 Credit\\n\"\n            \"‚Ä¢ Perfect for trying out models\\n\\n\"\n            \"üî• **Popular Choice**\\n\"\n            \"‚Ä¢ 1000 Stars ‚Üí 12 Credits\\n\"\n            \"‚Ä¢ Great value for regular users\\n\\n\"\n            \"üíé **Best Value**\\n\"\n            \"‚Ä¢ 2000 Stars ‚Üí 25 Credits\\n\"\n            \"‚Ä¢ More credits per star\\n\\n\"\n            \"üöÄ **Premium Package**\\n\"\n            \"‚Ä¢ 5000 Stars ‚Üí 75 Credits\\n\"\n            \"‚Ä¢ Excellent savings per credit\\n\\n\"\n            \"üëë **Ultimate Package**\\n\"\n            \"‚Ä¢ 10000 Stars ‚Üí 175 Credits\\n\"\n            \"‚Ä¢ Maximum value for power users\\n\\n\"\n            \"‚ú® **All packages include:**\\n\"\n            \"‚Ä¢ Access to all 5 AI models\\n\"\n            \"‚Ä¢ Image-to-video support\\n\"\n            \"‚Ä¢ Instant video delivery\\n\"\n            \"‚Ä¢ Credits never expire\\n\\n\"\n            \"üí° Choose a package above to proceed!\"\n        )\n        \n        try:\n            if callback.message and isinstance(callback.message, Message):\n                await callback.message.edit_text(package_text, reply_markup=packages_keyboard, parse_mode=\"Markdown\")\n            else:\n                await bot.send_message(callback.from_user.id, package_text, reply_markup=packages_keyboard, parse_mode=\"Markdown\")\n        except Exception:\n            # Fallback: send new message if editing fails\n            await bot.send_message(callback.from_user.id, package_text, reply_markup=packages_keyboard, parse_mode=\"Markdown\")\n        \n    except Exception as e:\n        logger.error(f\"Error in show_packages_callback: {e}\")\n        if callback.message and hasattr(callback.message, 'answer'):\n            await callback.message.answer(\"‚ùå Error showing packages. Please try /buy command.\")\n        else:\n            await bot.send_message(callback.from_user.id, \"‚ùå Error showing packages. Please try /buy command.\")\n\n@dp.callback_query(F.data.startswith(\"buy_package_\"))\nasync def buy_package_callback(callback: CallbackQuery):\n    \"\"\"Handle credit package purchase\"\"\"\n    await callback.answer()\n    \n    if not callback.from_user:\n        return\n        \n    try:\n        # Extract package size from callback data\n        if not callback.data:\n            if callback.message and hasattr(callback.message, 'answer'):\n                await callback.message.answer(\"‚ùå Invalid package data.\")\n            else:\n                await bot.send_message(callback.from_user.id, \"‚ùå Invalid package data.\")\n            return\n        package_stars = int(callback.data.replace(\"buy_package_\", \"\"))\n        user_id = callback.from_user.id\n        \n        # Package details\n        packages = {\n            100: {\"credits\": 1, \"title\": \"Starter Package\", \"description\": \"1 credit for video generation\"},\n            1000: {\"credits\": 12, \"title\": \"Popular Package\", \"description\": \"12 credits for video generation\"},\n            2000: {\"credits\": 25, \"title\": \"Best Value Package\", \"description\": \"25 credits for video generation\"},\n            5000: {\"credits\": 75, \"title\": \"Premium Package\", \"description\": \"75 credits for video generation\"},\n            10000: {\"credits\": 175, \"title\": \"Ultimate Package\", \"description\": \"175 credits for video generation\"}\n        }\n        \n        if package_stars not in packages:\n            if callback.message and hasattr(callback.message, 'answer'):\n                await callback.message.answer(\"‚ùå Invalid package selected.\")\n            else:\n                await bot.send_message(callback.from_user.id, \"‚ùå Invalid package selected.\")\n            return\n            \n        package = packages[package_stars]\n        \n        # Get the account ID that should receive credits (group or user)\n        account_id = get_callback_account_id(callback)\n        \n        # Create invoice with account_id in payload\n        price = LabeledPrice(label=f\"{package['credits']} Video Credits\", amount=package_stars)\n        \n        await bot.send_invoice(\n            chat_id=user_id,\n            title=package[\"title\"],\n            description=package[\"description\"],\n            payload=f\"credit_package_{package_stars}_account_{account_id}\",\n            provider_token=\"\",  # Empty for Telegram Stars (XTR)\n            currency=\"XTR\",  # Telegram Stars\n            prices=[price],\n            need_email=False,\n            need_phone_number=False,\n            need_name=False,\n            need_shipping_address=False,\n            is_flexible=False\n        )\n        \n        # Send confirmation message\n        confirm_text = (\n            f\"üí∞ **Payment Request Sent!**\\n\\n\"\n            f\"‚≠ê **Package:** {package_stars} Telegram Stars\\n\"\n            f\"üí≥ **Credits:** {package['credits']} credits\\n\\n\"\n            f\"üì± **Complete payment in Telegram to receive your credits instantly!**\"\n        )\n        \n        if callback.message:\n            await callback.message.answer(confirm_text, parse_mode=\"Markdown\")\n        else:\n            await bot.send_message(user_id, confirm_text, parse_mode=\"Markdown\")\n        \n    except Exception as e:\n        logger.error(f\"Error in buy_package_callback: {e}\")\n        if callback.message:\n            await callback.message.answer(f\"‚ùå Payment error: {str(e)}\\n\\nPlease contact @niftysolsol for support.\")\n        else:\n            await bot.send_message(callback.from_user.id, f\"‚ùå Payment error: {str(e)}\\n\\nPlease contact @niftysolsol for support.\")\n\n@dp.callback_query(F.data == \"back_to_start\")\nasync def back_to_start_callback(callback: CallbackQuery):\n    \"\"\"Return to main menu\"\"\"\n    await callback.answer()\n    \n    if not callback.from_user:\n        return\n        \n    try:\n        user_id = callback.from_user.id\n        account_id = get_callback_account_id(callback)\n        credits = get_credits(account_id)\n        \n        welcome_text = f\"\"\"\nüé¨ **Welcome to AI Video Generator Bot!**\n\nüëã **Hello {callback.from_user.first_name or 'there'}!**\n\nüí≥ **Your Credits:** {credits} {'credit' if credits == 1 else 'credits'}\n\nüöÄ **Quick Start:**\n‚Ä¢ Use /generate to create amazing videos\n‚Ä¢ Need credits? Try /buy for great packages\n‚Ä¢ Get help anytime with /help\n\nüéØ **Available Models:** 7 AI models including Veo 3, Runway Gen-3, Sora 2, and Kling 2.1\n\nüí∞ **Pricing:** 1 credit per video, bulk discounts available\n\n‚ú® Ready to create something amazing?\n\"\"\"\n        \n        # Create welcome keyboard with quick actions\n        welcome_keyboard = InlineKeyboardMarkup(inline_keyboard=[\n            [InlineKeyboardButton(text=\"üé¨ Generate Video\", callback_data=\"quick_generate\")],\n            [InlineKeyboardButton(text=\"üí≥ Buy Credits\", callback_data=\"show_packages\"),\n             InlineKeyboardButton(text=\"‚ùì Help & Guide\", callback_data=\"help_main\")],\n            [InlineKeyboardButton(text=\"üìä My Stats\", callback_data=\"user_stats\")]\n        ])\n        \n        try:\n            if callback.message and isinstance(callback.message, Message):\n                await callback.message.edit_text(welcome_text, reply_markup=welcome_keyboard, parse_mode=\"Markdown\")\n            else:\n                await bot.send_message(user_id, welcome_text, reply_markup=welcome_keyboard, parse_mode=\"Markdown\")\n        except Exception:\n            # Fallback: send new message if editing fails\n            await bot.send_message(user_id, welcome_text, reply_markup=welcome_keyboard, parse_mode=\"Markdown\")\n        \n    except Exception as e:\n        logger.error(f\"Error in back_to_start_callback: {e}\")\n        if callback.message and hasattr(callback.message, 'answer'):\n            await callback.message.answer(\"‚ùå Error returning to menu. Please use /start.\")\n        else:\n            await bot.send_message(callback.from_user.id, \"‚ùå Error returning to menu. Please use /start.\")\n\n@dp.callback_query(F.data == \"help_contact\")\nasync def help_contact_callback(callback: CallbackQuery):\n    \"\"\"Show contact support information\"\"\"\n    if not callback.from_user:\n        return\n    \n    try:\n        contact_keyboard = InlineKeyboardMarkup(inline_keyboard=[\n            [InlineKeyboardButton(text=\"üõ†Ô∏è Troubleshooting\", callback_data=\"help_troubleshoot\")],\n            [InlineKeyboardButton(text=\"üîô Help Menu\", callback_data=\"help_main\")]\n        ])\n        \n        help_text = (\n            \"üë§ **Contact Support**\\n\\n\"\n            \"üí¨ **Get Human Help:**\\n\"\n            \"‚Ä¢ Support: @niftysolsol\\n\"\n            \"‚Ä¢ Response time: 2-24 hours\\n\"\n            \"‚Ä¢ Response time: 2-24 hours\\n\\n\"\n            \"üìù **When Contacting Include:**\\n\"\n            \"‚Ä¢ Your user ID (shown in stats)\\n\"\n            \"‚Ä¢ Generation ID if available\\n\"\n            \"‚Ä¢ Description of the problem\\n\"\n            \"‚Ä¢ Screenshots if helpful\\n\\n\"\n            \"üöÄ **Before Contacting:**\\n\"\n            \"‚Ä¢ Try troubleshooting guide\\n\"\n            \"‚Ä¢ Check your credits balance\\n\"\n            \"‚Ä¢ Restart with /start\\n\"\n            \"‚Ä¢ Try a different model\\n\\n\"\n            \"üí∞ **Refund Policy:**\\n\"\n            \"‚Ä¢ Failed generations: Auto-refunded\\n\"\n            \"‚Ä¢ Technical issues: Case-by-case\\n\"\n            \"‚Ä¢ Payment problems: Contact support\\n\\n\"\n            \"üôè **We're here to help make your experience amazing!**\"\n        )\n        \n        await safe_edit_message(callback, help_text, reply_markup=contact_keyboard, parse_mode=\"Markdown\")\n        \n        await callback.answer()\n        \n    except Exception as e:\n        logger.error(f\"Error in help_contact_callback: {e}\")\n        await callback.answer(\"‚ùå Error loading contact info.\")\n\n# ===== ADMIN CALLBACKS (Restricted Access) =====\n@dp.callback_query(F.data == \"admin_give_credits\")\nasync def admin_give_credits_callback(callback: CallbackQuery):\n    \"\"\"Admin only - Give credits to users\"\"\"\n    if not callback.from_user or not is_admin(callback.from_user.id):\n        await callback.answer(\"‚ùå Access denied.\", show_alert=True)\n        return\n    \n    try:\n        give_credits_text = (\n            \"üí≥ **Give Free Credits**\\n\\n\"\n            \"üìù **Instructions:**\\n\"\n            \"Send me a message in this format:\\n\\n\"\n            \"`/give_credits USER_ID AMOUNT`\\n\\n\"\n            \"üìñ **Examples:**\\n\"\n            \"‚Ä¢ `/give_credits 1020468360 10` - Give 10 credits to user\\n\"\n            \"‚Ä¢ `/give_credits -123456789 50` - Give 50 credits to group\\n\\n\"\n            \"üîç **Finding User IDs:**\\n\"\n            \"‚Ä¢ Use 'User Lookup' to search\\n\"\n            \"‚Ä¢ Check user stats for their ID\\n\"\n            \"‚Ä¢ Negative IDs = Groups\\n\"\n            \"‚Ä¢ Positive IDs = Users\\n\\n\"\n            \"‚ö†Ô∏è **Admin Only** - This action is logged.\"\n        )\n        \n        back_keyboard = InlineKeyboardMarkup(inline_keyboard=[\n            [InlineKeyboardButton(text=\"üîô Admin Panel\", callback_data=\"admin_back\")]\n        ])\n        \n        await safe_edit_message(callback, give_credits_text, reply_markup=back_keyboard, parse_mode=\"Markdown\")\n        await callback.answer()\n        \n    except Exception as e:\n        logger.error(f\"Error in admin_give_credits_callback: {e}\")\n        await callback.answer(\"‚ùå Admin error occurred.\")\n\n@dp.callback_query(F.data == \"admin_view_users\")\nasync def admin_view_users_callback(callback: CallbackQuery):\n    \"\"\"Admin only - View all users with credits\"\"\"\n    if not callback.from_user or not is_admin(callback.from_user.id):\n        await callback.answer(\"‚ùå Access denied.\", show_alert=True)\n        return\n    \n    try:\n        users_list = []\n        groups_list = []\n        \n        for account_id, credits in user_credits.items():\n            if account_id > 0:\n                users_list.append(f\"üë§ `{account_id}`: {credits} credits\")\n            else:\n                groups_list.append(f\"üë• `{account_id}`: {credits} credits\")\n        \n        users_text = \"üìä **All Accounts with Credits**\\n\\n\"\n        \n        if users_list:\n            users_text += \"üë• **Users:**\\n\" + \"\\n\".join(users_list[:10])\n            if len(users_list) > 10:\n                users_text += f\"\\n... and {len(users_list) - 10} more users\"\n        \n        if groups_list:\n            users_text += \"\\n\\nüè¢ **Groups:**\\n\" + \"\\n\".join(groups_list[:5])\n            if len(groups_list) > 5:\n                users_text += f\"\\n... and {len(groups_list) - 5} more groups\"\n        \n        if not users_list and not groups_list:\n            users_text += \"No accounts found with credits.\"\n        \n        users_text += f\"\\n\\nüìà **Total Accounts:** {len(user_credits)}\"\n        \n        back_keyboard = InlineKeyboardMarkup(inline_keyboard=[\n            [InlineKeyboardButton(text=\"üîô Admin Panel\", callback_data=\"admin_back\")]\n        ])\n        \n        await safe_edit_message(callback, users_text, reply_markup=back_keyboard, parse_mode=\"Markdown\")\n        await callback.answer()\n        \n    except Exception as e:\n        logger.error(f\"Error in admin_view_users_callback: {e}\")\n        await callback.answer(\"‚ùå Admin error occurred.\")\n\n@dp.callback_query(F.data == \"admin_user_lookup\")\nasync def admin_user_lookup_callback(callback: CallbackQuery):\n    \"\"\"Admin only - Lookup specific user\"\"\"\n    if not callback.from_user or not is_admin(callback.from_user.id):\n        await callback.answer(\"‚ùå Access denied.\", show_alert=True)\n        return\n    \n    try:\n        lookup_text = (\n            \"üîç **User Lookup**\\n\\n\"\n            \"üìù **Instructions:**\\n\"\n            \"Send me a message in this format:\\n\\n\"\n            \"`/lookup USER_ID`\\n\\n\"\n            \"üìñ **Examples:**\\n\"\n            \"‚Ä¢ `/lookup 1020468360` - Check user's balance\\n\"\n            \"‚Ä¢ `/lookup -123456789` - Check group's balance\\n\\n\"\n            \"‚ÑπÔ∏è **This will show:**\\n\"\n            \"‚Ä¢ Current credit balance\\n\"\n            \"‚Ä¢ Account type (user/group)\\n\"\n            \"‚Ä¢ Last activity (if available)\\n\\n\"\n            \"‚ö†Ô∏è **Admin Only** - Lookup is logged.\"\n        )\n        \n        back_keyboard = InlineKeyboardMarkup(inline_keyboard=[\n            [InlineKeyboardButton(text=\"üîô Admin Panel\", callback_data=\"admin_back\")]\n        ])\n        \n        await safe_edit_message(callback, lookup_text, reply_markup=back_keyboard, parse_mode=\"Markdown\")\n        await callback.answer()\n        \n    except Exception as e:\n        logger.error(f\"Error in admin_user_lookup_callback: {e}\")\n        await callback.answer(\"‚ùå Admin error occurred.\")\n\n@dp.callback_query(F.data == \"admin_stats\")\nasync def admin_stats_callback(callback: CallbackQuery):\n    \"\"\"Admin only - Show bot statistics\"\"\"\n    if not callback.from_user or not is_admin(callback.from_user.id):\n        await callback.answer(\"‚ùå Access denied.\", show_alert=True)\n        return\n    \n    try:\n        total_users = sum(1 for uid in user_credits.keys() if uid > 0)\n        total_groups = sum(1 for uid in user_credits.keys() if uid < 0)\n        total_credits_issued = sum(user_credits.values())\n        active_generations = len(pending_generations)\n        \n        stats_text = (\n            \"üìà **Bot Statistics**\\n\\n\"\n            f\"üë• **Users:** {total_users}\\n\"\n            f\"üè¢ **Groups:** {total_groups}\\n\"\n            f\"üí≥ **Total Credits Issued:** {total_credits_issued}\\n\"\n            f\"üé¨ **Active Generations:** {active_generations}\\n\\n\"\n            \"üìä **Top Users by Credits:**\\n\"\n        )\n        \n        # Show top users by credits\n        sorted_users = sorted([(uid, credits) for uid, credits in user_credits.items() if uid > 0], \n                            key=lambda x: x[1], reverse=True)[:5]\n        \n        for i, (uid, credits) in enumerate(sorted_users, 1):\n            stats_text += f\"{i}. User `{uid}`: {credits} credits\\n\"\n        \n        back_keyboard = InlineKeyboardMarkup(inline_keyboard=[\n            [InlineKeyboardButton(text=\"üîô Admin Panel\", callback_data=\"admin_back\")]\n        ])\n        \n        await safe_edit_message(callback, stats_text, reply_markup=back_keyboard, parse_mode=\"Markdown\")\n        await callback.answer()\n        \n    except Exception as e:\n        logger.error(f\"Error in admin_stats_callback: {e}\")\n        await callback.answer(\"‚ùå Admin error occurred.\")\n\n@dp.callback_query(F.data == \"admin_back\")\nasync def admin_back_callback(callback: CallbackQuery):\n    \"\"\"Admin only - Go back to admin panel\"\"\"\n    if not callback.from_user or not is_admin(callback.from_user.id):\n        await callback.answer(\"‚ùå Access denied.\", show_alert=True)\n        return\n    \n    try:\n        # Recreate admin panel\n        admin_keyboard = InlineKeyboardMarkup(inline_keyboard=[\n            [InlineKeyboardButton(text=\"üí≥ Give Credits\", callback_data=\"admin_give_credits\")],\n            [InlineKeyboardButton(text=\"üìä View All Users\", callback_data=\"admin_view_users\")],\n            [InlineKeyboardButton(text=\"üîç User Lookup\", callback_data=\"admin_user_lookup\")],\n            [InlineKeyboardButton(text=\"üìà Bot Stats\", callback_data=\"admin_stats\")]\n        ])\n        \n        admin_text = (\n            \"üîß **Admin Panel**\\n\\n\"\n            f\"üëã Welcome back, @niftysolsol!\\n\\n\"\n            \"üõ†Ô∏è **Available Actions:**\\n\"\n            \"‚Ä¢ **Give Credits** - Add free credits to any user/group\\n\"\n            \"‚Ä¢ **View All Users** - See all accounts with credits\\n\"\n            \"‚Ä¢ **User Lookup** - Check specific user's balance\\n\"\n            \"‚Ä¢ **Bot Stats** - Overall usage statistics\\n\\n\"\n            \"üîí **Admin Only** - This panel is invisible to regular users.\"\n        )\n        \n        await safe_edit_message(callback, admin_text, reply_markup=admin_keyboard, parse_mode=\"Markdown\")\n        await callback.answer()\n        \n    except Exception as e:\n        logger.error(f\"Error in admin_back_callback: {e}\")\n        await callback.answer(\"‚ùå Admin error occurred.\")\n\n@dp.message(GenerationStates.waiting_for_prompt)\nasync def process_prompt(message: Message, state: FSMContext):\n    \"\"\"Handle text prompt input\"\"\"\n    try:\n        if not message.text:\n            await message.answer(\"Please provide a text prompt.\")\n            return\n            \n        prompt = message.text\n        is_group = is_group_chat(message)\n        user_id = message.from_user.id if message.from_user else 0\n        \n        # Generate a unique generation ID for tracking\n        generation_id = f\"gen_{int(time.time() * 1000)}_{user_id}\"\n        \n        # Store prompt and generation info in state\n        await state.update_data(prompt=prompt, generation_id=generation_id)\n        \n        # Track user prompt message for cleanup in groups\n        if is_group:\n            track_message_for_cleanup(generation_id, message.message_id, message.chat.id, \"user\")\n        \n        # Check if model is text-only (skip image upload)\n        model = user_models.get(user_id, \"veo3_fast\")\n        \n        if model in TEXT_ONLY_MODELS:\n            # Text-only model - skip image upload and generate directly\n            account_id = get_credit_account_id(message)\n            \n            # Deduct credits\n            if not deduct_credits(account_id, 1):\n                await message.answer(\"‚ùå Insufficient credits!\")\n                await state.clear()\n                return\n            \n            # Send to BRS AI API with enhanced progress tracking\n            try:\n                # Show generating message\n                model_name = AVAILABLE_MODELS.get(model, \"Unknown Model\")\n                generating_msg = await message.answer(\n                    f\"üé¨ **Generating video...**\\n\\n\"\n                    f\"ü§ñ **Model:** {model_name}\\n\"\n                    f\"üìù **Prompt:** {prompt[:100]}{'...' if len(prompt) > 100 else ''}\\n\\n\"\n                    f\"‚è≥ This may take 1-3 minutes...\",\n                    parse_mode=\"Markdown\"\n                )\n                \n                # Track generating message for cleanup in groups\n                if is_group:\n                    track_message_for_cleanup(generation_id, generating_msg.message_id, message.chat.id, \"bot\")\n                \n                # Prepare generation request\n                callback_url = f\"{WEBHOOK_URL.rstrip('/')}/brs_callback\"\n                \n                # Store generation info for callback\n                pending_generations[generation_id] = {\n                    \"user_id\": user_id,\n                    \"chat_id\": message.chat.id,\n                    \"account_id\": account_id,\n                    \"model\": model,\n                    \"prompt\": prompt,\n                    \"image_url\": None,\n                    \"timestamp\": time.time()\n                }\n                save_pending_generations()\n                \n                # Make API call\n                async with http_session.post(\n                    \"https://api.kie.ai/v1/video/generations\",\n                    headers={\n                        \"Authorization\": f\"Bearer {BRS_AI_API_KEY}\",\n                        \"Content-Type\": \"application/json\"\n                    },\n                    json={\n                        \"model\": model,\n                        \"prompt\": prompt,\n                        \"callback_url\": callback_url,\n                        \"metadata\": {\"generation_id\": generation_id}\n                    },\n                    timeout=30\n                ) as resp:\n                    if resp.status == 200:\n                        result = await resp.json()\n                        task_id = result.get(\"id\") or result.get(\"task_id\")\n                        \n                        if task_id:\n                            # Update with task ID\n                            pending_generations[generation_id][\"task_id\"] = task_id\n                            save_pending_generations()\n                            \n                            logger.info(f\"Video generation started for user {user_id}, task_id: {task_id}\")\n                        else:\n                            logger.warning(f\"No task_id in response: {result}\")\n                    else:\n                        error_text = await resp.text()\n                        raise Exception(f\"API error {resp.status}: {error_text}\")\n                        \n            except Exception as e:\n                # Refund credits on error\n                add_credits(account_id, 1)\n                await message.answer(f\"‚ùå Error starting generation: {str(e)}\\nCredits refunded.\")\n                logger.error(f\"Generation error for user {user_id}: {e}\")\n            \n            await state.clear()\n            return\n        \n        # Image-to-video model - show image upload prompt\n        skip_keyboard = InlineKeyboardMarkup(inline_keyboard=[\n            [InlineKeyboardButton(text=\"‚è≠Ô∏è Skip Image\", callback_data=\"skip_image\")],\n            [InlineKeyboardButton(text=\"‚ùì Image Tips\", callback_data=\"help_image\")]\n        ])\n        \n        # Different UI for groups vs private chats\n        if is_group:\n            # Simplified message for groups\n            response_msg = await message.answer(\n                \"üì∏ **Upload image or type 'skip'**\",\n                reply_markup=skip_keyboard,\n                parse_mode=\"Markdown\"\n            )\n        else:\n            # Full detailed message for private chats\n            response_msg = await message.answer(\n                \"üñºÔ∏è **Step 2:** Upload an image (optional)\\n\\n\"\n                \"üì∏ **Supported formats:** JPG, PNG, WebP, GIF\\n\"\n                \"üìè **Best quality:** High resolution (1024x1024+)\\n\\n\"\n                \"üí° **Pro tip:** Images work great with I2V models!\\n\\n\"\n                \"üì§ **Upload your image now** or tap Skip to continue:\",\n                reply_markup=skip_keyboard,\n                parse_mode=\"Markdown\"\n            )\n        \n        # Track bot response for cleanup in groups\n        if is_group:\n            track_message_for_cleanup(generation_id, response_msg.message_id, message.chat.id, \"bot\")\n        \n        await state.set_state(GenerationStates.waiting_for_image)\n        \n    except Exception as e:\n        logger.error(f\"Error in process_prompt: {e}\")\n        await message.answer(\"‚ùå An error occurred. Please try again later.\")\n        await state.clear()\n\n@dp.message(GenerationStates.waiting_for_image)\nasync def process_image_or_skip(message: Message, state: FSMContext):\n    \"\"\"Handle image upload or skip\"\"\"\n    if not message.from_user:\n        return\n        \n    try:\n        user_id = message.from_user.id\n        data = await state.get_data()\n        prompt = data.get(\"prompt\")\n        \n        if not prompt:\n            await message.answer(\"Error: No prompt found. Please start over with /generate\")\n            await state.clear()\n            return\n            \n        model = user_models.get(user_id, \"veo3_fast\")\n        image_path = None\n        \n        if message.text and message.text.lower() == \"skip\":\n            # No image, proceed with generation\n            pass\n        elif message.photo:\n            # User uploaded an image - properly download it\n            try:\n                photo = message.photo[-1]  # Get the highest resolution\n                await message.answer(\"‚è≥ Downloading image...\")\n                \n                # Download the image from Telegram\n                image_content = await download_telegram_file(photo.file_id)\n                if image_content:\n                    # Upload to temporary storage\n                    filename = f\"{photo.file_id}.jpg\"\n                    image_path = await upload_image_to_temporary_storage(image_content, filename)\n                    if image_path:\n                        await message.answer(\"‚úÖ Image downloaded and processed successfully!\")\n                    else:\n                        await message.answer(\"‚ùå Failed to process image. Proceeding without image.\")\n                else:\n                    await message.answer(\"‚ùå Failed to download image. Proceeding without image.\")\n                    \n            except Exception as e:\n                logger.error(f\"Error processing image: {e}\")\n                await message.answer(\"‚ùå Error processing image. Proceeding without image.\")\n        else:\n            await message.answer(\"‚ùå Please upload an image or type 'skip' to proceed.\")\n            return\n        \n        # Deduct credits\n        account_id = get_credit_account_id(message)\n        if not deduct_credits(account_id, 1):\n            await message.answer(\"‚ùå Insufficient credits!\")\n            await state.clear()\n            return\n        \n        # Send to BRS AI API with enhanced progress tracking  \n        try:\n            # Get generation ID from state\n            data = await state.get_data()\n            generation_id = data.get(\"generation_id\", f\"gen_{int(time.time() * 1000)}_{user_id}\")\n            is_group = is_group_chat(message)\n            \n            # Track user's image upload or skip message for cleanup in groups\n            if is_group:\n                track_message_for_cleanup(generation_id, message.message_id, message.chat.id, \"user\")\n            \n            # Simplified progress message for groups, detailed for private chats\n            if is_group:\n                progress_msg = await message.answer(\"üé¨ **Generating...**\")\n                # Track the progress message for cleanup\n                track_message_for_cleanup(generation_id, progress_msg.message_id, message.chat.id, \"bot\")\n            else:\n                progress_msg = await message.answer(\n                    \"üé¨ **Starting Video Generation**\\n\\n\"\n                    \"‚è≥ **Status:** Initializing request...\\n\"\n                f\"ü§ñ **Model:** {AVAILABLE_MODELS[model]}\\n\"\n                f\"üìù **Prompt:** _{prompt[:50]}{'...' if len(prompt) > 50 else ''}_\\n\\n\"\n                \"‚è±Ô∏è **Estimated time:** 2-5 minutes\\n\"\n                \"üîÑ **Please wait while we process your request...**\",\n                parse_mode=\"Markdown\"\n            )\n            \n            task_id = await send_to_brs_api(prompt, model, image_path)\n            \n            # Migrate message cleanup records from temporary generation_id to actual task_id\n            if generation_id in message_cleanup:\n                # Move cleanup data to task_id key\n                cleanup_data = message_cleanup[generation_id]\n                if task_id in message_cleanup:\n                    # Merge with existing task_id data\n                    existing_data = message_cleanup[task_id]\n                    existing_data[\"messages\"].extend(cleanup_data.get(\"messages\", []))\n                    logger.info(f\"Merged cleanup data for {task_id}\")\n                else:\n                    # Simple migration\n                    message_cleanup[task_id] = cleanup_data\n                del message_cleanup[generation_id]\n                save_message_cleanup()\n                logger.info(f\"Migrated cleanup records from {generation_id} to {task_id}\")\n                logger.info(f\"Total messages tracked for cleanup: {len(message_cleanup[task_id].get('messages', []))}\")\n            \n            # Update progress with task ID (only for private chats)\n            if not is_group:\n                try:\n                    await progress_msg.edit_text(\n                        \"‚úÖ **Video Generation Started**\\n\\n\"\n                        f\"üÜî **Generation ID:** `{task_id}`\\n\"\n                        f\"ü§ñ **Model:** {AVAILABLE_MODELS[model]}\\n\"\n                        f\"üìù **Prompt:** _{prompt[:50]}{'...' if len(prompt) > 50 else ''}_\\n\\n\"\n                        \"üé¨ **Processing steps:**\\n\"\n                        \"‚úÖ Request submitted\\n\"\n                        \"‚è≥ Analyzing prompt...\\n\"\n                        \"‚è≥ Generating video...\\n\"\n                        \"‚è≥ Finalizing output...\\n\\n\"\n                        \"üîî **You'll be notified when ready!**\",\n                        parse_mode=\"Markdown\"\n                    )\n                except Exception:\n                    # If edit fails, send new message\n                    await message.answer(\n                        \"‚úÖ **Video Generation Started**\\n\\n\"\n                        f\"üÜî **Generation ID:** `{task_id}`\\n\"\n                        \"üîî **You'll be notified when ready!**\",\n                        parse_mode=\"Markdown\"\n                    )\n            \n            # Store pending generation with task_id\n            pending_generations[task_id] = {\n                \"user_id\": user_id,\n                \"chat_id\": message.chat.id,  # Store original chat for video delivery\n                \"account_id\": account_id,  # Store the account that was charged\n                \"prompt\": prompt,\n                \"model\": model,\n                \"image_path\": image_path\n            }\n            save_pending_generations()  # Persist generation data\n            \n            # Note: Progress message was already tracked under generation_id and migrated to task_id above\n            \n            # Final confirmation with helpful info (only for private chats)\n            if not is_group:\n                final_keyboard = InlineKeyboardMarkup(inline_keyboard=[\n                    [InlineKeyboardButton(text=\"üìä Check Status\", callback_data=\"user_stats\")],\n                    [InlineKeyboardButton(text=\"üé¨ Generate Another\", callback_data=\"quick_generate\")]\n                ])\n                \n                await message.answer(\n                    \"üéâ **Generation in Progress!**\\n\\n\"\n                    f\"üÜî **Tracking ID:** `{task_id}`\\n\\n\"\n                    \"‚è∞ **What happens next:**\\n\"\n                    \"‚Ä¢ Processing usually takes 2-5 minutes\\n\"\n                    \"‚Ä¢ You'll get a notification when ready\\n\"\n                    \"‚Ä¢ Video will be delivered directly to this chat\\n\\n\"\n                    \"üîÑ **You can generate more videos while waiting!**\",\n                    reply_markup=final_keyboard,\n                    parse_mode=\"Markdown\"\n                )\n            \n        except Exception as e:\n            # Refund credits on error\n            account_id = get_credit_account_id(message)\n            add_credits(account_id, 1)\n            await message.answer(f\"‚ùå Error starting generation: {str(e)}\\nCredits refunded.\")\n            logger.error(f\"Generation error for user {user_id}: {e}\")\n        \n        await state.clear()\n        \n    except Exception as e:\n        logger.error(f\"Error in process_image_or_skip: {e}\")\n        await message.answer(\"‚ùå An error occurred. Please try again later.\")\n        await state.clear()\n\n# Add comprehensive help command\n@dp.message(Command(\"admin\"))\nasync def cmd_admin(message: Message):\n    \"\"\"Handle /admin command - Admin only\"\"\"\n    if not message.from_user:\n        return\n        \n    user_id = message.from_user.id\n    \n    # Check if user is admin\n    if not is_admin(user_id):\n        # Don't reveal admin command exists to non-admins\n        return\n        \n    try:\n        # Admin panel with credit management\n        admin_keyboard = InlineKeyboardMarkup(inline_keyboard=[\n            [InlineKeyboardButton(text=\"üí≥ Give Credits\", callback_data=\"admin_give_credits\")],\n            [InlineKeyboardButton(text=\"üìä View All Users\", callback_data=\"admin_view_users\")],\n            [InlineKeyboardButton(text=\"üîç User Lookup\", callback_data=\"admin_user_lookup\")],\n            [InlineKeyboardButton(text=\"üìà Bot Stats\", callback_data=\"admin_stats\")]\n        ])\n        \n        admin_text = (\n            \"üîß **Admin Panel**\\n\\n\"\n            f\"üëã Welcome back, @niftysolsol!\\n\\n\"\n            \"üõ†Ô∏è **Available Actions:**\\n\"\n            \"‚Ä¢ **Give Credits** - Add free credits to any user/group\\n\"\n            \"‚Ä¢ **View All Users** - See all accounts with credits\\n\"\n            \"‚Ä¢ **User Lookup** - Check specific user's balance\\n\"\n            \"‚Ä¢ **Bot Stats** - Overall usage statistics\\n\\n\"\n            \"üîí **Admin Only** - This panel is invisible to regular users.\"\n        )\n        \n        await message.answer(admin_text, reply_markup=admin_keyboard, parse_mode=\"Markdown\")\n        \n    except Exception as e:\n        logger.error(f\"Error in cmd_admin: {e}\")\n        await message.answer(\"‚ùå Admin error occurred.\")\n\n@dp.message(Command(\"give_credits\"))\nasync def cmd_give_credits(message: Message):\n    \"\"\"Admin only - Give credits to users via command\"\"\"\n    if not message.from_user or not is_admin(message.from_user.id):\n        # Don't reveal command exists to non-admins\n        return\n    \n    try:\n        # Parse arguments\n        if not message.text or len(message.text.split()) != 3:\n            await message.answer(\n                \"‚ùå **Invalid Format**\\n\\n\"\n                \"Use: `/give_credits USER_ID AMOUNT`\\n\\n\"\n                \"Examples:\\n\"\n                \"‚Ä¢ `/give_credits 1020468360 10`\\n\"\n                \"‚Ä¢ `/give_credits -123456789 50`\",\n                parse_mode=\"Markdown\"\n            )\n            return\n        \n        _, user_id_str, amount_str = message.text.split()\n        \n        # Validate inputs\n        try:\n            target_user_id = int(user_id_str)\n            amount = int(amount_str)\n        except ValueError:\n            await message.answer(\"‚ùå USER_ID and AMOUNT must be numbers\")\n            return\n        \n        if amount <= 0 or amount > 1000:\n            await message.answer(\"‚ùå Amount must be between 1 and 1000\")\n            return\n        \n        # Give credits\n        current_credits = get_credits(target_user_id)\n        add_credits(target_user_id, amount)\n        \n        # Determine account type\n        account_type = \"Group\" if target_user_id < 0 else \"User\"\n        \n        # Log the admin action\n        logger.info(f\"Admin {message.from_user.id} gave {amount} credits to {account_type.lower()} {target_user_id}\")\n        \n        await message.answer(\n            f\"‚úÖ **Credits Added Successfully**\\n\\n\"\n            f\"üéØ **Target:** {account_type} `{target_user_id}`\\n\"\n            f\"üí≥ **Added:** {amount} credits\\n\"\n            f\"üí∞ **New Balance:** {current_credits + amount} credits\\n\\n\"\n            f\"üìù **Action logged** by admin @{message.from_user.username or 'niftysolsol'}\",\n            parse_mode=\"Markdown\"\n        )\n        \n    except Exception as e:\n        logger.error(f\"Error in cmd_give_credits: {e}\")\n        await message.answer(\"‚ùå Error giving credits. Please try again.\")\n\n@dp.message(Command(\"lookup\"))\nasync def cmd_lookup(message: Message):\n    \"\"\"Admin only - Look up user credit balance\"\"\"\n    if not message.from_user or not is_admin(message.from_user.id):\n        # Don't reveal command exists to non-admins\n        return\n    \n    try:\n        # Parse arguments\n        if not message.text or len(message.text.split()) != 2:\n            await message.answer(\n                \"‚ùå **Invalid Format**\\n\\n\"\n                \"Use: `/lookup USER_ID`\\n\\n\"\n                \"Examples:\\n\"\n                \"‚Ä¢ `/lookup 1020468360`\\n\"\n                \"‚Ä¢ `/lookup -123456789`\",\n                parse_mode=\"Markdown\"\n            )\n            return\n        \n        _, user_id_str = message.text.split()\n        \n        # Validate input\n        try:\n            target_user_id = int(user_id_str)\n        except ValueError:\n            await message.answer(\"‚ùå USER_ID must be a number\")\n            return\n        \n        # Look up account\n        credits = get_credits(target_user_id)\n        account_type = \"Group\" if target_user_id < 0 else \"User\"\n        has_account = target_user_id in user_credits\n        \n        # Check if user has selected a model (users only)\n        selected_model = None\n        if target_user_id > 0 and target_user_id in user_models:\n            selected_model = AVAILABLE_MODELS[user_models[target_user_id]]\n        \n        # Log the admin lookup\n        logger.info(f\"Admin {message.from_user.id} looked up {account_type.lower()} {target_user_id}\")\n        \n        lookup_text = f\"üîç **Account Lookup**\\n\\n\"\n        lookup_text += f\"üéØ **Target:** {account_type} `{target_user_id}`\\n\"\n        lookup_text += f\"üí≥ **Credits:** {credits}\\n\"\n        lookup_text += f\"üìä **Account Status:** {'Active' if has_account else 'New (no credits yet)'}\\n\"\n        \n        if selected_model:\n            lookup_text += f\"ü§ñ **Selected Model:** {selected_model}\\n\"\n        \n        lookup_text += f\"\\nüìù **Lookup by:** @{message.from_user.username or 'niftysolsol'}\"\n        \n        await message.answer(lookup_text, parse_mode=\"Markdown\")\n        \n    except Exception as e:\n        logger.error(f\"Error in cmd_lookup: {e}\")\n        await message.answer(\"‚ùå Error looking up account. Please try again.\")\n\n@dp.message(Command(\"help\"))\nasync def cmd_help(message: Message):\n    \"\"\"Handle /help command with comprehensive help menu\"\"\"\n    if not message.from_user:\n        return\n        \n    try:\n        help_keyboard = InlineKeyboardMarkup(inline_keyboard=[\n            [InlineKeyboardButton(text=\"üé¨ Video Generation\", callback_data=\"help_generate\")],\n            [InlineKeyboardButton(text=\"üí≥ Credits & Payment\", callback_data=\"help_credits\")],\n            [InlineKeyboardButton(text=\"ü§ñ AI Models Guide\", callback_data=\"help_models\")],\n            [InlineKeyboardButton(text=\"üñºÔ∏è Image Upload Tips\", callback_data=\"help_image\")],\n            [InlineKeyboardButton(text=\"üõ†Ô∏è Troubleshooting\", callback_data=\"help_troubleshoot\")],\n            [InlineKeyboardButton(text=\"üë§ Contact Support\", callback_data=\"help_contact\")]\n        ])\n        \n        help_text = (\n            \"‚ùì **AI Video Bot - Complete Help Guide**\\n\\n\"\n            f\"Welcome {message.from_user.first_name or 'there'}! Choose a topic below for detailed assistance:\\n\\n\"\n            \"üé¨ **Video Generation** - Step-by-step video creation\\n\"\n            \"üí≥ **Credits & Payment** - Understanding the credit system\\n\"\n            \"ü§ñ **AI Models** - Compare all 5 available models\\n\"\n            \"üñºÔ∏è **Image Tips** - Optimize your image uploads\\n\"\n            \"üõ†Ô∏è **Troubleshooting** - Fix common issues\\n\"\n            \"üë§ **Contact** - Get human support\\n\\n\"\n            \"üî• **Quick Commands:**\\n\"\n            \"‚Ä¢ `/generate` - Start creating videos\\n\"\n            \"‚Ä¢ `/buy` - Purchase credits\\n\"\n            \"‚Ä¢ `/reset` - Clear selection and start fresh\\n\"\n            \"‚Ä¢ `/start` - Return to main menu\\n\\n\"\n            \"üí° **Tip:** Use the buttons below for instant help!\"\n        )\n        \n        await message.answer(help_text, reply_markup=help_keyboard, parse_mode=\"Markdown\")\n        \n    except Exception as e:\n        logger.error(f\"Error in cmd_help: {e}\")\n        await message.answer(\"‚ùå An error occurred. Please try again later.\")\n\n@dp.message(Command(\"buy\"))\nasync def cmd_buy(message: Message):\n    \"\"\"Handle /buy command - Show credit packages\"\"\"\n    if not message.from_user:\n        return\n        \n    try:\n        user_id = message.from_user.id\n        account_id = get_credit_account_id(message)\n        credits = get_credits(account_id)\n        \n        # Create credit packages keyboard\n        packages_keyboard = InlineKeyboardMarkup(inline_keyboard=[\n            [InlineKeyboardButton(text=\"üéØ Starter: 100‚≠ê ‚Üí 1 Credit\", callback_data=\"buy_package_100\")],\n            [InlineKeyboardButton(text=\"üî• Popular: 1000‚≠ê ‚Üí 12 Credits\", callback_data=\"buy_package_1000\")],\n            [InlineKeyboardButton(text=\"üíé Best Value: 2000‚≠ê ‚Üí 25 Credits\", callback_data=\"buy_package_2000\")],\n            [InlineKeyboardButton(text=\"üöÄ Premium: 5000‚≠ê ‚Üí 75 Credits\", callback_data=\"buy_package_5000\")],\n            [InlineKeyboardButton(text=\"üëë Ultimate: 10000‚≠ê ‚Üí 175 Credits\", callback_data=\"buy_package_10000\")],\n            [InlineKeyboardButton(text=\"üîô Back to Menu\", callback_data=\"back_to_start\")]\n        ])\n        \n        package_text = (\n            \"‚≠ê **Credit Packages - Telegram Stars**\\n\\n\"\n            f\"üí≥ **Current Balance:** {credits} credits\\n\\n\"\n            \"üéØ **Starter Package**\\n\"\n            \"‚Ä¢ 100 Stars ‚Üí 1 Credit\\n\"\n            \"‚Ä¢ Perfect for trying out models\\n\\n\"\n            \"üî• **Popular Choice**\\n\"\n            \"‚Ä¢ 1000 Stars ‚Üí 12 Credits\\n\"\n            \"‚Ä¢ Great value for regular users\\n\\n\"\n            \"üíé **Best Value**\\n\"\n            \"‚Ä¢ 2000 Stars ‚Üí 25 Credits\\n\"\n            \"‚Ä¢ More credits per star\\n\\n\"\n            \"üöÄ **Premium Package**\\n\"\n            \"‚Ä¢ 5000 Stars ‚Üí 75 Credits\\n\"\n            \"‚Ä¢ Excellent savings per credit\\n\\n\"\n            \"üëë **Ultimate Package**\\n\"\n            \"‚Ä¢ 10000 Stars ‚Üí 175 Credits\\n\"\n            \"‚Ä¢ Maximum value for power users\\n\\n\"\n            \"‚ú® **All packages include:**\\n\"\n            \"‚Ä¢ Access to all 5 AI models\\n\"\n            \"‚Ä¢ Image-to-video support\\n\"\n            \"‚Ä¢ Instant video delivery\\n\"\n            \"‚Ä¢ Credits never expire\\n\\n\"\n            \"üí° Choose a package above to proceed!\"\n        )\n        \n        await message.answer(package_text, reply_markup=packages_keyboard, parse_mode=\"Markdown\")\n        \n    except Exception as e:\n        logger.error(f\"Error in cmd_buy: {e}\")\n        await message.answer(\"‚ùå An error occurred. Please try again later.\")\n\n@dp.pre_checkout_query()\nasync def process_pre_checkout(pre_checkout_query: PreCheckoutQuery):\n    \"\"\"Handle pre-checkout query\"\"\"\n    try:\n        if pre_checkout_query.id:\n            await bot.answer_pre_checkout_query(pre_checkout_query.id, ok=True)\n    except Exception as e:\n        logger.error(f\"Error in process_pre_checkout: {e}\")\n\n@dp.message(F.content_type == ContentType.SUCCESSFUL_PAYMENT)\nasync def process_successful_payment(message: Message):\n    \"\"\"Handle successful payment\"\"\"\n    if not message.from_user or not message.successful_payment:\n        return\n        \n    try:\n        user_id = message.from_user.id\n        payment = message.successful_payment\n        payload = payment.invoice_payload\n        \n        # Parse package from payload\n        if payload.startswith(\"credit_package_\"):\n            # Extract package_stars and account_id from payload\n            payload_parts = payload.split(\"_\")\n            package_stars = int(payload_parts[2])  # credit_package_XXX_account_YYY\n            \n            # Check if account_id is included in payload (new format)\n            if len(payload_parts) >= 5 and payload_parts[3] == \"account\":\n                account_id = int(payload_parts[4])\n            else:\n                # Legacy format - use user_id\n                account_id = user_id\n            \n            # Credit mapping\n            credit_packages = {\n                100: 1,\n                1000: 12,\n                2000: 25,\n                5000: 75,\n                10000: 175\n            }\n            \n            credits_to_add = credit_packages.get(package_stars, 0)\n            if credits_to_add > 0:\n                # Add credits to the correct account (group or user)\n                add_credits(account_id, credits_to_add)\n                \n                # Get the updated balance for display\n                if account_id == user_id:\n                    total_credits = get_user_credits(user_id)\n                    account_type = \"personal\"\n                else:\n                    total_credits = get_credits(account_id)\n                    account_type = \"group\"\n                \n                success_text = (\n                    \"üéâ **Payment Successful!**\\n\\n\"\n                    f\"‚≠ê **Purchased:** {package_stars} Telegram Stars\\n\"\n                    f\"üí≥ **Credits Added:** {credits_to_add}\\n\"\n                    f\"üìç **Added to:** {account_type} account\\n\\n\"\n                    f\"üí∞ **New Balance:** {total_credits} total credits\\n\\n\"\n                    \"üé¨ Ready to create videos! Use /generate to start.\"\n                )\n                \n                # CRITICAL FIX: Use bot.send_message to ensure correct user gets the message\n                await bot.send_message(user_id, success_text, parse_mode=\"Markdown\")\n            else:\n                # CRITICAL FIX: Use bot.send_message to ensure correct user gets the message\n                await bot.send_message(user_id, \"‚ùå Invalid package. Please contact support.\")\n        else:\n            # CRITICAL FIX: Use bot.send_message to ensure correct user gets the message\n            await bot.send_message(user_id, \"‚ùå Unknown payment. Please contact support.\")\n            \n    except Exception as e:\n        logger.error(f\"Error in process_successful_payment: {e}\")\n        # CRITICAL FIX: Use bot.send_message with user_id to prevent cross-user messages\n        if message.from_user:\n            await bot.send_message(message.from_user.id, \"‚ùå An error occurred processing your payment. Please contact @niftysolsol for support.\")\n        else:\n            logger.error(\"Payment error but no user found in message\")\n\n# aiohttp web handlers\nasync def brs_callback(request):\n    \"\"\"Handle BRS AI API callbacks with HMAC authentication\"\"\"\n    try:\n        # Get request body and headers for debugging\n        body = await request.read()\n        headers = dict(request.headers)\n        \n        # Log all headers to debug signature format\n        logger.info(f\"Callback headers: {headers}\")\n        \n        # Try multiple possible signature header formats\n        signature = (\n            request.headers.get('X-Signature', '') or\n            request.headers.get('X-HMAC-Signature', '') or\n            request.headers.get('X-Hub-Signature-256', '') or\n            request.headers.get('BRS-Signature', '') or\n            request.headers.get('Signature', '')\n        )\n        \n        logger.info(f\"Found signature: {signature}\")\n        \n        # TEMPORARY: Disable signature verification since BRS AI doesn't send signatures\n        # TODO: Contact BRS AI about signature implementation or implement IP whitelist\n        disable_verification = True  # os.getenv('DISABLE_SIGNATURE_VERIFICATION', '').lower() == 'true'\n        \n        if not disable_verification:\n            if not signature:\n                logger.error(\"Missing callback signature - potential attack attempt\")\n                return web.json_response({\"error\": \"Missing signature\"}, status=403)\n            \n            if not verify_callback_signature(body, signature):\n                logger.error(f\"Invalid callback signature from IP {request.remote} - security breach attempt\")\n                logger.error(f\"Expected signature verification failed for body length: {len(body)}\")\n                # Log additional security details without exposing sensitive info\n                logger.error(f\"Signature format received: {signature[:10]}...{signature[-10:] if len(signature) > 20 else ''}\")\n                return web.json_response({\"error\": \"Invalid signature\"}, status=403)\n            else:\n                logger.info(\"Callback signature verification successful\")\n        else:\n            logger.warning(\"SECURITY WARNING: Signature verification disabled for debugging - NOT FOR PRODUCTION!\")\n        \n        # Parse JSON data\n        try:\n            data = json.loads(body.decode('utf-8'))\n        except json.JSONDecodeError as e:\n            logger.error(f\"Invalid JSON in callback: {e}\")\n            return web.json_response({\"error\": \"Invalid JSON\"}, status=400)\n        \n        # Enhanced debugging for callback processing\n        logger.info(f\"=== Processing BRS AI Callback ===\")\n        logger.info(f\"Parsed JSON data: {json.dumps(data, indent=2)}\")\n        \n        # BRS AI callback format: {\"code\": 200, \"msg\": \"success\", \"data\": {\"taskId\": \"...\", \"info\": {\"resultUrls\": \"[\\\"url1\\\"]\"}}}\n        code = data.get('code')\n        msg = data.get('msg', '')\n        task_data = data.get('data', {})\n        generation_id = task_data.get('taskId') or task_data.get('task_id')\n        \n        logger.info(f\"Callback details - Code: {code}, Message: {msg}, TaskId: {generation_id}\")\n        \n        if not generation_id:\n            logger.warning(\"‚ùå No taskId in callback - rejecting\")\n            return web.json_response({\"error\": \"Missing taskId\"}, status=400)\n        \n        logger.info(f\"Current pending generations: {list(pending_generations.keys())}\")\n        \n        if generation_id not in pending_generations:\n            logger.warning(f\"‚ùå Unknown generation_id: {generation_id}\")\n            logger.info(f\"Available pending IDs: {list(pending_generations.keys())}\")\n            return web.json_response({\"error\": \"Unknown generation_id\"}, status=400)\n        \n        generation_info = pending_generations[generation_id]\n        user_id = generation_info['user_id']\n        logger.info(f\"‚úÖ Found generation for user {user_id}\")\n        \n        if code == 200:\n            # Success - extract video URLs from resultUrls JSON string\n            logger.info(\"‚úÖ Generation successful - processing video URLs\")\n            info = task_data.get('info', {})\n            result_urls_str = info.get('resultUrls', info.get('result_urls', []))\n            \n            # Check for Runway format (video_url directly in task_data)\n            if not result_urls_str and 'video_url' in task_data:\n                result_urls_str = [task_data['video_url']]\n                logger.info(f\"Found Runway format video_url: {result_urls_str}\")\n            \n            # Check for Wan2.2 format (resultJson) if no URLs found in info\n            if not result_urls_str and 'resultJson' in task_data:\n                try:\n                    result_json = json.loads(task_data['resultJson'])\n                    result_urls_str = result_json.get('resultUrls', [])\n                    logger.info(f\"Found Wan2.2 format URLs: {result_urls_str}\")\n                except json.JSONDecodeError as e:\n                    logger.error(f\"Failed to parse Wan2.2 resultJson: {e}\")\n            \n            logger.info(f\"Info object: {info}\")\n            logger.info(f\"Result URLs string: {result_urls_str}\")\n            \n            try:\n                # Handle both JSON string and list formats from BRS AI\n                if isinstance(result_urls_str, list):\n                    result_urls = result_urls_str  # Already a list\n                    logger.info(f\"Result URLs received as list: {result_urls}\")\n                else:\n                    result_urls = json.loads(result_urls_str)  # Parse JSON string\n                    logger.info(f\"Parsed result URLs from JSON: {result_urls}\")\n                \n                if result_urls and len(result_urls) > 0:\n                    video_url = result_urls[0]  # Use first video URL\n                    # Get original chat_id from pending generation\n                    gen_data = pending_generations.get(generation_id, {})\n                    original_chat_id = gen_data.get(\"chat_id\", user_id)  # Fallback to user_id\n                    logger.info(f\"üé¨ Sending video to chat {original_chat_id} (user {user_id}): {video_url}\")\n                    await send_video_to_chat(original_chat_id, video_url, generation_id)\n                    \n                    # Clear selected model after successful generation\n                    if user_id in user_models:\n                        del user_models[user_id]\n                        save_user_models()  # Persist model clearing\n                        logger.info(f\"‚úÖ Cleared model selection for user {user_id}\")\n                else:\n                    logger.error(\"‚ùå No video URLs in successful callback\")\n                    # For failure refunds, use the original generation's account type\n                    gen_data = pending_generations.get(generation_id, {})\n                    original_account_id = gen_data.get(\"account_id\", user_id)\n                    original_chat_id = gen_data.get(\"chat_id\", user_id)\n                    add_credits(original_account_id, 1)\n                    await send_failure_message(original_chat_id, generation_id)\n            except (json.JSONDecodeError, IndexError, TypeError) as e:\n                logger.error(f\"‚ùå Error parsing resultUrls: {e}\")\n                logger.error(f\"Raw resultUrls data: {result_urls_str} (type: {type(result_urls_str)})\")\n                # For failure refunds, use the original generation's account type\n                gen_data = pending_generations.get(generation_id, {})\n                original_account_id = gen_data.get(\"account_id\", user_id)\n                add_credits(original_account_id, 1)\n                await send_failure_message(user_id, generation_id)\n        else:\n            # Failure - refund credits\n            logger.info(f\"Video generation failed: {msg}\")\n            # For failure refunds, use the original generation's account type\n            gen_data = pending_generations.get(generation_id, {})\n            original_account_id = gen_data.get(\"account_id\", user_id)\n            add_credits(original_account_id, 1)\n            await send_failure_message(user_id, generation_id)\n        \n        # Clean up\n        if generation_id in pending_generations:\n            # Clean up temporary image file if it exists\n            image_path = generation_info.get('image_path')\n            if image_path and os.path.exists(image_path):\n                try:\n                    os.remove(image_path)\n                    logger.info(f\"Cleaned up temporary image file: {image_path}\")\n                except Exception as e:\n                    logger.error(f\"Error cleaning up image file {image_path}: {e}\")\n            \n            del pending_generations[generation_id]\n            save_pending_generations()  # Persist cleanup\n        \n        return web.json_response({\"status\": \"ok\"})\n        \n    except Exception as e:\n        logger.error(f\"Error processing callback: {e}\")\n        return web.json_response({\"error\": \"Internal server error\"}, status=500)\n\nasync def send_video_to_chat(chat_id: int, video_url: str, generation_id: str):\n    \"\"\"Send completed video to chat (user or group) using aiohttp\"\"\"\n    try:\n        global http_session\n        if not http_session:\n            http_session = ClientSession()\n            \n        # Download video using aiohttp\n        async with http_session.get(video_url) as response:\n            if response.status == 200:\n                video_content = await response.read()\n                \n                # Create video file for sending\n                video_file = BufferedInputFile(video_content, filename=f\"video_{generation_id}.mp4\")\n                \n                video_msg = await bot.send_video(\n                    chat_id=chat_id,\n                    video=video_file,\n                    caption=\"üé¨ Your video is ready!\"\n                )\n                logger.info(f\"Successfully sent video to chat {chat_id}\")\n                \n                # Clean up all intermediate messages in groups, keep only the final video\n                await cleanup_generation_messages(generation_id, keep_final_message_id=video_msg.message_id)\n                \n            else:\n                # If download fails, send the URL instead\n                fallback_msg = await bot.send_message(\n                    chat_id=chat_id,\n                    text=f\"‚úÖ Video generated successfully!\\nDownload: {video_url}\"\n                )\n                logger.warning(f\"Could not download video from {video_url}, sent URL instead\")\n                \n                # Clean up all intermediate messages in groups, keep only the final message\n                await cleanup_generation_messages(generation_id, keep_final_message_id=fallback_msg.message_id)\n                \n    except Exception as e:\n        logger.error(f\"Error sending video to chat {chat_id}: {e}\")\n        try:\n            fallback_msg = await bot.send_message(\n                chat_id=chat_id,\n                text=f\"‚úÖ Video generated successfully!\\nDownload: {video_url}\"\n            )\n            # Clean up all intermediate messages in groups, keep only the final message\n            await cleanup_generation_messages(generation_id, keep_final_message_id=fallback_msg.message_id)\n        except Exception as send_error:\n            logger.error(f\"Error sending fallback message to chat {chat_id}: {send_error}\")\n            # Clean up all intermediate messages even if fallback fails\n            await cleanup_generation_messages(generation_id)\n\nasync def send_failure_message(chat_id: int, generation_id: str):\n    \"\"\"Send enhanced failure message to chat (user or group)\"\"\"\n    try:\n        retry_keyboard = InlineKeyboardMarkup(inline_keyboard=[\n            [InlineKeyboardButton(text=\"üîÑ Try Again\", callback_data=\"quick_generate\")],\n            [InlineKeyboardButton(text=\"üí° Get Help\", callback_data=\"help_troubleshoot\"),\n             InlineKeyboardButton(text=\"üí≥ Check Credits\", callback_data=\"user_stats\")]\n        ])\n        \n        failure_msg = await bot.send_message(\n            chat_id=chat_id,\n            text=(\n                \"‚ùå **Video Generation Failed**\\n\\n\"\n                f\"Generation ID: `{generation_id}`\\n\\n\"\n                \"üí∞ **Credits Refunded:** 1 credit has been returned to your account\\n\\n\"\n                \"üîÑ **What to try:**\\n\"\n                \"‚Ä¢ Check your prompt for clarity\\n\"\n                \"‚Ä¢ Try a different model\\n\"\n                \"‚Ä¢ Ensure stable internet connection\\n\"\n                \"‚Ä¢ Contact support if this persists\\n\\n\"\n                \"üìû **Support:** @niftysolsol\\n\\n\"\n                \"üëÜ **Quick actions below:**\"\n            ),\n            reply_markup=retry_keyboard,\n            parse_mode=\"Markdown\"\n        )\n        logger.info(f\"Sent enhanced failure message to chat {chat_id}\")\n        \n        # Clean up all intermediate messages in groups, keep only the final failure message\n        await cleanup_generation_messages(generation_id, keep_final_message_id=failure_msg.message_id)\n        \n    except Exception as e:\n        logger.error(f\"Error sending failure message to chat {chat_id}: {e}\")\n        # Clean up intermediate messages even if failure message fails\n        await cleanup_generation_messages(generation_id)\n\nasync def health_check(request):\n    \"\"\"Primary health check handler for Cloud Run deployment\"\"\"\n    return web.Response(text=\"OK\", status=200, content_type=\"text/plain\")\n\nasync def index_handler(request):\n    \"\"\"Root endpoint handler - same as health check\"\"\"\n    return web.Response(text=\"OK\", status=200, content_type=\"text/plain\")\n\nasync def health_handler(request):\n    \"\"\"Secondary health check endpoint\"\"\"\n    return web.Response(text=\"OK\", status=200, content_type=\"text/plain\")\n\nasync def serve_image(request):\n    \"\"\"Serve uploaded images for BRS AI to access with security hardening\"\"\"\n    try:\n        filename = request.match_info['filename']\n        \n        # SECURITY: Prevent directory traversal attacks\n        secure_filename = os.path.basename(filename)\n        if secure_filename != filename:\n            logger.warning(f\"Potential path traversal attempt blocked: {filename}\")\n            return web.Response(text=\"Access denied\", status=403)\n        \n        # SECURITY: Only allow specific file extensions and validate filename\n        allowed_extensions = ('.jpg', '.jpeg', '.png', '.gif', '.webp')\n        if not secure_filename.lower().endswith(allowed_extensions):\n            return web.Response(text=\"Invalid file type\", status=400)\n            \n        # SECURITY: Additional filename validation\n        if '..' in secure_filename or '/' in secure_filename or '\\\\' in secure_filename:\n            logger.warning(f\"Suspicious filename blocked: {secure_filename}\")\n            return web.Response(text=\"Invalid filename\", status=400)\n        \n        # SECURITY: Only serve from controlled directory\n        CONTROLLED_IMAGE_DIR = tempfile.gettempdir()\n        image_path = os.path.join(CONTROLLED_IMAGE_DIR, secure_filename)\n        \n        # SECURITY: Ensure the resolved path is still in the controlled directory\n        if not os.path.commonpath([CONTROLLED_IMAGE_DIR, os.path.dirname(image_path)]) == CONTROLLED_IMAGE_DIR:\n            logger.warning(f\"Path traversal attempt blocked: {image_path}\")\n            return web.Response(text=\"Access denied\", status=403)\n            \n        if not os.path.exists(image_path):\n            return web.Response(text=\"Image not found\", status=404)\n        \n        # SECURITY: Check file size before reading (max 50MB)\n        try:\n            file_stat = os.stat(image_path)\n            file_size = file_stat.st_size\n            MAX_FILE_SIZE = 50 * 1024 * 1024  # 50MB limit\n            \n            if file_size > MAX_FILE_SIZE:\n                logger.warning(f\"Large file access blocked: {secure_filename} ({file_size} bytes)\")\n                return web.Response(text=\"File too large\", status=413)\n                \n            # SECURITY: Check file age for TTL cleanup (delete files older than 24 hours)\n            import time\n            file_age = time.time() - file_stat.st_mtime\n            TTL_SECONDS = 24 * 60 * 60  # 24 hours\n            \n            if file_age > TTL_SECONDS:\n                logger.info(f\"Removing expired image file: {secure_filename}\")\n                try:\n                    os.remove(image_path)\n                except OSError:\n                    pass\n                return web.Response(text=\"Image expired\", status=404)\n                \n        except OSError as e:\n            logger.error(f\"Error checking file stats for {secure_filename}: {e}\")\n            return web.Response(text=\"File access error\", status=500)\n        \n        # SECURITY: Only serve files with telegram_image_ prefix (created by bot)\n        if not secure_filename.startswith('telegram_image_'):\n            logger.warning(f\"Unauthorized file access attempt: {secure_filename}\")\n            return web.Response(text=\"Access denied\", status=403)\n            \n        # Serve the image file with size limit reading\n        try:\n            with open(image_path, 'rb') as f:\n                image_data = f.read(MAX_FILE_SIZE)  # Limit read size as additional safety\n                \n        except IOError as e:\n            logger.error(f\"Error reading image file {secure_filename}: {e}\")\n            return web.Response(text=\"File read error\", status=500)\n            \n        # Determine content type with proper mapping\n        content_type = 'application/octet-stream'  # Safe default\n        file_ext = secure_filename.lower().split('.')[-1]\n        content_type_map = {\n            'jpg': 'image/jpeg',\n            'jpeg': 'image/jpeg', \n            'png': 'image/png',\n            'gif': 'image/gif',\n            'webp': 'image/webp'\n        }\n        content_type = content_type_map.get(file_ext, 'application/octet-stream')\n        \n        # SECURITY: Add security headers\n        security_headers = {\n            'Cache-Control': 'public, max-age=3600',  # Cache for 1 hour\n            'X-Content-Type-Options': 'nosniff',      # Prevent MIME sniffing\n            'X-Frame-Options': 'DENY',                # Prevent embedding\n            'Content-Security-Policy': \"default-src 'none'\",  # Strict CSP\n            'X-Robots-Tag': 'noindex, nofollow',      # Prevent indexing\n            'Content-Length': str(len(image_data))    # Explicit content length\n        }\n            \n        return web.Response(\n            body=image_data,\n            content_type=content_type,\n            headers=security_headers\n        )\n        \n    except Exception as e:\n        logger.error(f\"Error serving image: {e}\")\n        return web.Response(text=\"Internal server error\", status=500)\n\nasync def webhook_handler(request):\n    \"\"\"Handle incoming Telegram webhook updates\"\"\"\n    try:\n        # Get the raw JSON data\n        update_data = await request.json()\n        \n        # Process the update through aiogram dispatcher\n        telegram_update = Update(**update_data)\n        await dp.feed_update(bot=bot, update=telegram_update)\n        \n        return web.Response(text=\"OK\", status=200)\n        \n    except Exception as e:\n        logger.error(f\"Error processing webhook update: {e}\")\n        return web.Response(text=\"Error\", status=500)\n\nasync def setup_webhook(app):\n    \"\"\"Set up webhook with Telegram on startup\"\"\"\n    try:\n        # Initialize HTTP session first\n        await init_http_session()\n        \n        # Set webhook URL with Telegram (clean up any double slashes)\n        webhook_url = f\"{WEBHOOK_URL.rstrip('/')}/webhook\"\n        await bot.set_webhook(\n            url=webhook_url,\n            drop_pending_updates=True,\n            allowed_updates=[\"message\", \"callback_query\", \"pre_checkout_query\"]\n        )\n        logger.info(f\"‚úÖ Webhook set successfully: {webhook_url}\")\n        \n    except Exception as e:\n        logger.error(f\"‚ùå Error setting webhook: {e}\")\n\nasync def cleanup_webhook(app):\n    \"\"\"Clean up webhook and HTTP session on shutdown\"\"\"\n    try:\n        # Delete webhook\n        await bot.delete_webhook()\n        logger.info(\"Webhook deleted\")\n        \n        # Cleanup HTTP session\n        await cleanup_http_session()\n        logger.info(\"Webhook cleanup completed\")\n        \n    except Exception as e:\n        logger.error(f\"Error cleaning up webhook: {e}\")\n\nasync def create_web_app():\n    \"\"\"Create aiohttp web application with webhook mode\"\"\"\n    app = web.Application()\n    \n    # Add startup and cleanup hooks for webhook mode\n    app.on_startup.append(setup_webhook)\n    app.on_cleanup.append(cleanup_webhook)\n    \n    # Add routes with explicit error handling\n    try:\n        # Multiple health check routes for maximum Cloud Run compatibility\n        app.router.add_get('/', health_check)  # Primary root health check\n        app.router.add_get('/health', health_check)  # Standard health endpoint  \n        app.router.add_get('/healthz', health_check)  # Kubernetes style\n        app.router.add_get('/ready', health_check)  # Readiness probe\n        app.router.add_get('/alive', health_check)  # Liveness probe\n        \n        # Telegram webhook routes\n        app.router.add_post('/webhook', webhook_handler)\n        \n        # AI callback routes\n        app.router.add_post('/brs_callback', brs_callback)\n        app.router.add_post('/kie_callback', brs_callback)  # Legacy support\n        \n        # Image serving route\n        app.router.add_get('/images/{filename}', serve_image)\n        \n        logger.info(\"‚úÖ All routes configured successfully - Health checks: /, /health, /healthz, /ready, /alive\")\n    except Exception as e:\n        logger.error(f\"‚ùå Error configuring routes: {e}\")\n        raise\n    \n    return app\n\nasync def init_http_session():\n    \"\"\"Initialize global HTTP session\"\"\"\n    global http_session\n    http_session = ClientSession()\n    logger.info(\"HTTP session initialized\")\n\nasync def cleanup_http_session():\n    \"\"\"Cleanup global HTTP session\"\"\"\n    global http_session\n    if http_session:\n        await http_session.close()\n        logger.info(\"HTTP session closed\")\n\ndef validate_environment():\n    \"\"\"Validate all required environment variables before startup\"\"\"\n    required_vars = ['BOT_TOKEN', 'BRS_AI_API_KEY', 'WEBHOOK_URL', 'CALLBACK_SECRET']\n    missing_vars = [var for var in required_vars if not os.getenv(var)]\n    \n    if missing_vars:\n        error_msg = f\"Missing required environment variables: {', '.join(missing_vars)}\"\n        logger.error(error_msg)\n        raise ValueError(error_msg)\n    \n    logger.info(\"‚úÖ All required environment variables validated\")\n\ndef main():\n    \"\"\"Main function for deployment - create and run aiohttp app\"\"\"\n    try:\n        # Validate environment variables first\n        validate_environment()\n        \n        # Use $PORT environment variable for deployment (default to 5000 for local dev)\n        port = int(os.getenv(\"PORT\", 5000))\n        \n        logger.info(f\"üöÄ Starting BRS Telegram Bot server on port {port}\")\n        logger.info(f\"üì° Callback URL: {WEBHOOK_URL.rstrip('/')}/brs_callback\")\n        logger.info(f\"ü§ñ Bot Token: {BOT_TOKEN[:20]}...\")\n        \n        # Create web app with startup/cleanup hooks\n        app = asyncio.run(create_web_app())\n        \n        logger.info(\"‚úÖ Web application created successfully\")\n        \n        # Run the web application - this will trigger startup hooks\n        web.run_app(app, host='0.0.0.0', port=port, access_log=None)\n        \n    except ValueError as e:\n        logger.error(f\"‚ùå Environment validation failed: {e}\")\n        raise\n    except Exception as e:\n        logger.error(f\"‚ùå Error in main: {e}\")\n        logger.error(f\"Error type: {type(e).__name__}\")\n        import traceback\n        logger.error(f\"Traceback: {traceback.format_exc()}\")\n        raise\n\n@dp.callback_query(F.data == \"reset_model\")\nasync def reset_model_selection(callback: CallbackQuery, state: FSMContext):\n    \"\"\"Handle model selection reset\"\"\"\n    if not callback.from_user:\n        return\n        \n    try:\n        user_id = callback.from_user.id\n        \n        # Clear selected model\n        if user_id in user_models:\n            del user_models[user_id]\n            save_user_models()  # Persist model clearing\n        \n        # Clear any FSM state\n        await state.clear()\n        \n        account_id = get_callback_account_id(callback)\n        credits = get_credits(account_id)\n        keyboard = create_model_selection_keyboard()\n        \n        await safe_edit_message(\n            callback,\n            \"üîÑ **Model Selection Reset**\\n\\n\"\n            f\"üí≥ **Your Balance:** `{credits}` credits\\n\\n\"\n            \"ü§ñ **Choose Your AI Model:**\\n\\n\"\n            \"‚ö° **Fast:** Quick generation (1-2 min)\\n\"\n            \"üéµ **Audio:** High quality with sound\\n\"\n            \"üöÄ **Advanced:** Premium features\\n\"\n            \"üí∞ **Affordable:** Budget-friendly options\\n\\n\"\n            \"üëÜ **Select a model to get started:**\",\n            keyboard,\n            \"Markdown\"\n        )\n        await callback.answer(\"üîÑ Model selection reset!\")\n        \n    except Exception as e:\n        logger.error(f\"Error in reset_model_selection: {e}\")\n        await callback.answer(\"‚ùå Error resetting model selection.\")\n\nif __name__ == \"__main__\":\n    # Run the bot and web server for deployment\n    main()","size_bytes":130270},"pyproject.toml":{"content":"[project]\nname = \"repl-nix-workspace\"\nversion = \"0.1.0\"\ndescription = \"Add your description here\"\nrequires-python = \">=3.11\"\ndependencies = [\n    \"aiofiles>=24.1.0\",\n    \"aiogram>=3.22.0\",\n    \"aiohttp>=3.12.15\",\n    \"cryptography>=46.0.1\",\n    \"flask>=3.1.2\",\n    \"python-dotenv>=1.1.1\",\n    \"python-multipart>=0.0.20\",\n    \"requests>=2.32.5\",\n]\n","size_bytes":347},"replit.md":{"content":"# Telegram Video Generation Bot\n\nA sophisticated Telegram bot that generates AI videos using the KIE.ai API with Telegram Stars payment system.\n\n## Overview\n\nThis bot allows users to:\n- Generate AI videos using 7 advanced AI models (Veo 3, Runway Gen-3, Wan 2.2, Kling 2.1, Sora 2)\n- Purchase credits using Telegram Stars (XTR)\n- Upload optional images for video generation (text-only models like Sora 2 T2V skip this step)\n- Receive generated videos directly in Telegram\n\n## Features Implemented\n\n### ‚úÖ Bot Commands\n- `/start` - Welcome message with current credit balance\n- `/generate` - Video generation with model selection and prompts\n- `/buy` - Purchase credits using Telegram Stars\n\n### ‚úÖ Payment System\n- **Telegram Stars (XTR)** integration\n- 1 credit = 100 Stars ($1.30 equivalent)\n- Automatic credit deduction and refunds\n- Secure payment processing\n\n### ‚úÖ Video Generation\n- **7 AI Models Available**: Veo 3 Fast, Runway Gen-3, Wan 2.2 (T2V/I2V), Kling 2.1 (Standard/Pro/Master), Sora 2 (T2V/I2V)\n- Model selection via inline keyboard with descriptive names\n- Text prompt input with validation\n- Smart image upload - automatically skipped for text-only models (Sora 2 T2V, Wan 2.2 T2V)\n- Optional image upload for image-to-video models\n- Integration with KIE.ai API\n\n### ‚úÖ Architecture\n- **Async/await throughout** - Uses aiogram and aiohttp\n- **Secure callback handling** - HMAC signature verification\n- **Basic image handling** - Downloads from Telegram (requires external storage setup)\n- **Error handling** - Comprehensive try/catch blocks\n- **Credit system** - In-memory tracking with refund logic\n\n## Project Architecture\n\n```\nmain.py\n‚îú‚îÄ‚îÄ Bot Setup (aiogram)\n‚îú‚îÄ‚îÄ aiohttp Web Server (replaces Flask)\n‚îú‚îÄ‚îÄ Command Handlers (/start, /generate, /buy)\n‚îú‚îÄ‚îÄ FSM States (prompt input, image upload)\n‚îú‚îÄ‚îÄ Payment Processing (Telegram Stars)\n‚îú‚îÄ‚îÄ KIE.ai API Integration\n‚îî‚îÄ‚îÄ Callback Handler (secure with HMAC)\n```\n\n## Required Environment Variables\n\nThe bot requires these API keys to function:\n\n| Variable | Description | How to Get |\n|----------|-------------|------------|\n| `BOT_TOKEN` | Telegram Bot Token | Message @BotFather ‚Üí /newbot |\n| `BRS_AI_API_KEY` or `KIE_AI_API_KEY` | BRS AI API Key (supports both names) | Visit https://kie.ai/api-key |\n| `PAYMENT_PROVIDER_TOKEN` | Not needed for XTR | Leave empty (Telegram Stars) |\n| `CALLBACK_SECRET` | Strong secret for HMAC verification | Generate a random string (32+ characters) |\n| `WEBHOOK_URL` | Your Replit's public URL | Copy from browser address bar when running |\n\n## User Flow\n\n1. **Start**: User sends `/start` ‚Üí See welcome message and credit balance\n2. **Purchase Credits**: `/buy` ‚Üí Pay with Telegram Stars ‚Üí Credits added\n3. **Generate Video**: \n   - `/generate` ‚Üí Select model ‚Üí Enter prompt ‚Üí Optional image upload\n   - Bot deducts 1 credit and sends request to KIE.ai\n   - KIE.ai processes video and sends callback\n   - Bot delivers finished video to user\n4. **Error Handling**: Credits refunded if generation fails\n\n## Technical Details\n\n### Payment Integration\n- Uses Telegram Stars (XTR) for payments\n- Empty `provider_token` for digital goods\n- Pre-checkout validation and successful payment handling\n- Credit tracking in memory (scalable to database)\n\n### Security Features\n- HMAC SHA-256 signature verification on callbacks\n- Input validation and sanitization\n- Secure error handling without information leakage\n- Proper async/await to prevent race conditions\n\n### KIE.ai Integration\n- Async HTTP requests using aiohttp\n- Basic image file handling (downloads from Telegram)\n- **Note**: Images require external storage setup for KIE.ai access\n- Callback URL for completion notifications\n- Generation ID tracking for user mapping\n\n## Current Status\n\n‚úÖ **MVP Implementation** - Core features implemented\n‚úÖ **Critical Fix Applied** - Persistent credit storage implemented (Dec 26, 2025)\n‚úÖ **Admin System** - Full admin panel with credit management (Sept 28, 2025)\n‚úÖ **Production Deploy Config** - VM deployment configured for always-on bot (Sept 28, 2025)\n‚úÖ **Sora 2 Models Added** - Both text-to-video and image-to-video variants integrated (Oct 6, 2025)\n‚ö†Ô∏è **Image Upload Limitation** - Requires external storage setup\nüöÄ **Ready for Production** - Bot configured for Reserved VM deployment with 7 AI models\n\n## Production Deployment Guide\n\n### üöÄ **Publishing to Always-On Production**\n\n**Important**: The bot works in development but stops when you close the chat because it's running in dev mode. For production:\n\n1. **Click \"Publish\" Button** in the top toolbar\n2. **Select \"Reserved VM\"** (not Autoscale) for always-on operation\n3. **Choose Background Worker** app type (bot doesn't need web interface)\n4. **Configure Resources**:\n   - Minimum: 0.25 vCPU, 1GB RAM (sufficient for bot)\n   - Upgrade if needed for high traffic\n5. **Environment Variables**: Copy all secrets from dev to production\n6. **Deploy**: Click \"Publish\" - bot will run 24/7\n\n**Why Reserved VM?**: Bots need persistent connections for Telegram webhooks. Autoscale deployments stop when inactive, breaking the bot.\n\n### üîß **Environment Setup**\n\n1. **Get Telegram Bot Token**:\n   - Message @BotFather on Telegram\n   - Use `/newbot` command and follow instructions\n\n2. **Get KIE.ai API Key**:\n   - Visit https://kie.ai/api-key\n   - Sign up and obtain API key\n\n3. **Set Up Environment Variables**:\n   - Click \"Tools\" ‚Üí \"Secrets\" in Replit\n   - Add BOT_TOKEN and BRS_AI_API_KEY (or KIE_AI_API_KEY for legacy compatibility)\n   - Generate a strong CALLBACK_SECRET (random 32+ char string)\n   - Set WEBHOOK_URL to your production URL (will be provided after publishing)\n\n## Dependencies Installed\n\n- `aiogram` - Modern Telegram Bot framework\n- `aiohttp` - Async HTTP client/server\n- `aiofiles` - Async file operations\n- `python-multipart` - File upload handling\n\n## Architecture Decisions\n\n- **Single Event Loop**: Uses aiohttp to eliminate threading issues\n- **Secure Callbacks**: HMAC verification prevents spoofed requests  \n- **Async Throughout**: All operations use async/await for better performance\n- **State Management**: FSM for multi-step user interactions\n- **Error Recovery**: Credit refunds and user notifications on failures\n- **Polling Updates**: Uses long polling for simplicity (no webhook setup needed)\n\n## Important Setup Notes\n\n- **WEBHOOK_URL**: Must be set to your actual Replit public URL (visible when running)\n- **CALLBACK_SECRET**: Generate a strong random string for security\n- **Image Uploads**: Current implementation downloads images but may need external storage for KIE.ai to access them\n- **Testing**: Bot is ready for testing once proper environment variables are set\n\n## Recent Updates\n\n### üé¨ Sora 2 Models Integration (Oct 6, 2025)\n- **Added**: Sora 2 Text-to-Video and Image-to-Video models\n- **Feature**: Text-only models automatically skip image upload step\n- **Implementation**: Full API integration with KIE.ai's Sora 2 endpoints\n- **Result**: Bot now supports 7 AI models total\n\n### üîß Credit Storage Fix (Dec 26, 2025)\n- **Issue**: Credits were lost on bot restart due to in-memory storage\n- **Solution**: Implemented persistent JSON file storage (`user_credits.json`)\n- **Result**: Credits now persist permanently across restarts\n- **Compensation**: Affected users received free credits\n\n## Known Limitations\n\n- **Image handling**: Requires external storage service for full functionality\n- **Local development**: Use polling instead of webhooks for simplicity\n\nThe bot is ready for testing and follows Telegram's latest 2025 API standards for Stars payments. For production use, consider adding database persistence and proper image storage.","size_bytes":7730},"attached_assets/content-1758917273726.md":{"content":"![cover](https://kie.ai/cdn-cgi/image/width=640,quality=85,fit=scale-down,format=webp/images/home/bg_cover.svg)\n\n# Access the Best Video, Image & Music Models in One API\n\nAll your AI APIs for video, image, music, and chat ‚Äî lower cost than Fal.ai, fast, and developer-friendly.\n\n[Explore AI API](https://kie.ai/dashboard) [API Documentation](https://docs.kie.ai/)\n\n99.9%\n\nUptime\n\n24.7s\n\nResponse Time\n\n24/7\n\nSupport\n\n#1\n\nData Security\n\n## AI APIs for Any Project\n\n![AI Video Generation APIs](https://kie.ai/cdn-cgi/image/width=1920,quality=85,fit=scale-down,format=webp/images/home/use_01.png)\n\n### AI Video Generation APIs\n\nCreate high-quality videos with Veo 3, Veo 3 Fast, and Runway Aleph. Veo 3 offers synchronized audio, smooth motion, and realistic scenes, while Veo 3 Fast delivers quicker, lower-cost rendering. Runway Aleph adds advanced scene reasoning and precise camera control ‚Äî choose the best fit for your project.\n\n[Get API Key](https://kie.ai/api-key)\n\n![AI  Image Generation APIs](https://kie.ai/cdn-cgi/image/width=1920,quality=85,fit=scale-down,format=webp/images/home/use_02.png)\n\n### AI Image Generation APIs\n\nProduce high-quality, style-rich images with 4o Image API, Flux Kontext API, and Midjourney API. From photorealistic renders to consistent characters, our image APIs offer accuracy, versatility, and creative control in every generation.\n\n[Get API Key](https://kie.ai/api-key)\n\n![AI Music Generation APIs](https://kie.ai/cdn-cgi/image/width=1920,quality=85,fit=scale-down,format=webp/images/home/use_03.png)\n\n### AI Music Generation APIs\n\nCreate high-quality music programmatically with our Suno API, supporting V3.5, V4, V4.5, and V4.5 Plus models. Generate tracks with enhanced vocals, richer sound, better song structure, and smart prompts ‚Äî up to 8 minutes long. Designed for developers to integrate music generation into apps, games, and creative workflows with stable, low-latency performance.\n\n[Get API Key](https://kie.ai/api-key)\n\n![LLM & AI Chat APIs](https://kie.ai/cdn-cgi/image/width=1920,quality=85,fit=scale-down,format=webp/images/home/use_04.png)\n\n### LLM & AI Chat APIs\n\nPower your applications with advanced LLM and AI Chat APIs for natural conversations, coding help, and knowledge-based responses. Build smarter, more interactive user experiences with a single API key.\n\n[Get API Key](https://kie.ai/api-key)\n\n## Why Choose Kie.ai for API Integration\n\n### Affordable AI API Pricing with Credit System\n\nKie.ai offers affordable AI API access to leading models through a flexible credit-based system. This pay-as-you-go AI API approach ensures you only pay for what you use, making it cost-effective for startups, agencies, and enterprise projects.\n\n### Free Trial AI API in Playground\n\nTest any of our APIs for free in the AI API Playground before integration. Try different prompts, adjust parameters, and preview results without committing to a plan ‚Äî the perfect way to evaluate performance in a real environment.\n\n### Simple AI API Integration\n\nEasily integrate powerful AI capabilities with our clear AI API documentation and step-by-step examples. Whether you‚Äôre building a chatbot, generating images, or creating videos, adding AI to your product takes just minutes.\n\n### Fast & Scalable AI API Performance\n\nExperience 99.9% uptime, low latency AI API responses, and high concurrency AI API handling. From small-scale prototypes to large-scale production apps, Kie.ai delivers stable, reliable results every time.\n\n### Robust Data Security\n\nWe prioritize data security by employing encryption technology to ensure your information is safe and protected. Your data will not be exposed or compromised when using our services.\n\n### 24/7 Monitoring and Customer Support\n\nKie.ai provides 24/7 monitoring and customer support to ensure your APIs run smoothly. Our professional technical team is always available to assist you.\n\n## Popular AI Models You Can Access Today\n\n[![Google Veo 3](https://kie.ai/cdn-cgi/image/width=1920,quality=85,fit=scale-down,format=webp/images/home/models_01.png)\\\\\n\\\\\nVideo Generation\\\\\n\\\\\n**Google Veo 3** \\\\\nGoogle DeepMind‚Äôs latest AI video model with cinematic motion, strong prompt adherence, and synchronized audio output in native 1080p.](https://kie.ai/features/v3-api) [![Runway Aleph](https://kie.ai/cdn-cgi/image/width=1920,quality=85,fit=scale-down,format=webp/images/home/models_02.png)\\\\\n\\\\\nVideo Generation\\\\\n\\\\\n**Runway Aleph** \\\\\nRunway‚Äôs ‚Äúin-context‚Äù video model enables multi‚Äëtask editing ‚Äî seamlessly add/remove objects, relight footage, change angles or styles via text prompts.](https://kie.ai/runway/gen4-aleph) [![Suno API](https://kie.ai/cdn-cgi/image/width=1920,quality=85,fit=scale-down,format=webp/images/home/models_03.png)\\\\\n\\\\\nMusic Generation\\\\\n\\\\\n**Suno API** \\\\\nSuno‚Äôs advanced music generation model for realistic vocals, precise lyric-to-melody alignment, and high-quality multi-genre production.](https://kie.ai/suno-api) [![4o Image API](https://kie.ai/cdn-cgi/image/width=1920,quality=85,fit=scale-down,format=webp/images/home/models_04.png)\\\\\n\\\\\nImage Generation\\\\\n\\\\\n**4o Image API** \\\\\nOpenAI‚Äôs GPT-4o image model for high-fidelity visuals with accurate text rendering, flexible style control, and consistent quality across variations.](https://kie.ai/4o-image-api) [![Flux.1 Kontext](https://kie.ai/cdn-cgi/image/width=1920,quality=85,fit=scale-down,format=webp/images/home/models_05.png)\\\\\n\\\\\nImage Generation\\\\\n\\\\\n**Flux.1 Kontext** \\\\\nBlack Forest Labs‚Äô image model for vivid, coherent scenes with strong subject consistency, designed for detailed and repeatable outputs.](https://kie.ai/features/flux1-kontext) [![Midjourney v7](https://kie.ai/cdn-cgi/image/width=1920,quality=85,fit=scale-down,format=webp/images/home/models_06.png)\\\\\n\\\\\nImage Generation\\\\\n\\\\\n**Midjourney v7** \\\\\nMidjourney‚Äôs API for highly stylized, art-driven visuals, covering photorealism, concept art, and imaginative aesthetics.](https://kie.ai/features/mj-api)\n\n[Explore All](https://docs.kie.ai/)\n\n![cover](https://kie.ai/cdn-cgi/image/width=640,quality=85,fit=scale-down,format=webp/images/home/bg_cover_01.svg)\n\n## Frequently Asked Questions About Kie.ai\n\n## What is Kie.ai and how does it work?\n\nKie.ai is an AI platform providing advanced AI APIs designed for developers and businesses. It offers powerful AI APIs for text generation, music creation, video generation and more.\n\n* * *\n\n## Does Kie.ai offer a free trial for new users?\n\nYes, Kie.ai offers a free trial that allows you to explore the capabilities of our AI APIs before committing to any paid plan. This helps developers and businesses test the features in a real-world environment.\n\n* * *\n\n## What is the Kie.ai pricing model?\n\nKie.ai provides flexible pricing with a point-based system, making it cost-effective for startups. Detailed pricing plans are available on our website, catering to different usage levels.\n\n* * *\n\n## What AI APIs does Kie.ai provide for?\n\nKie.ai provides advanced AI model APIs, including Veo 3 for video generation, Runway API and Runway Aleph for video creation and style transfer, Suno API (V4) for music generation, and 4o Image API, Flux.1 Kontext API, and Midjourney API for image generation. We regularly update our platform with new model APIs to ensure developers have access to the latest capabilities.\n\n* * *\n\n## Is there API documentation available for Kie.ai?\n\nYes, Kie.ai provides comprehensive API documentation that covers integration steps, configuration details, and best practices. It ensures that developers can easily integrate our AI APIs into their systems with minimal effort.\n\n* * *\n\n## How do I integrate Kie.ai APIs into my project?\n\nTo integrate AI APIs, simply sign up for an account, obtain your API key, and follow the API documentation for configuration. If you encounter any issues, feel free to contact our support team at support@kie.ai for assistance.\n\n![placeholder](https://kie.ai/cdn-cgi/image/width=1920,quality=85,fit=scale-down,format=webp/https://deifkwefumgah.cloudfront.net/shadcnblocks/block/full-width-backgrounds/andrew-kliatskyi-LYZxo7oVFOI-unsplash.webp)![placeholder](https://kie.ai/cdn-cgi/image/width=1920,quality=85,fit=scale-down,format=webp/https://deifkwefumgah.cloudfront.net/shadcnblocks/block/full-width-backgrounds/denis96-gmsf4Zo2-rY-unsplash.webp)\n\n## Start Building with the World‚Äôs Top AI Models Today\n\nAccess video, image, music, and chat APIs in one platform ‚Äî faster, more affordable, and developer-friendly. Choose from models like Veo 3 API, Runway Aleph API, Suno API, and more, all with stable performance and simple integration.\n\n[Get Your Free API Key](https://kie.ai/api-key)","size_bytes":8687}},"version":1}